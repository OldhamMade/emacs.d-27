#+TITLE: Emacs Configuration
#+AUTHOR: Phillip B Oldham

* Introduction

This is the Emacs environment I (Phillip B Oldham, Oldham-Made) use for
development. This file is a literate programming document written with org-mode
and org-mode-babel. You can view config.org in a web browser on GitHub, or read
config.org directly in Emacs.

I generally only use Emacs on OS X, so there is a lot of customization around that OS.

Inspiration has been taking from the following sources:

- http://www.wilfred.me.uk/.emacs.d/init.org
- http://dl.dropboxusercontent.com/u/3968124/sacha-emacs.html
- https://github.com/jhenahan/emacs.d/blob/master/init.org
- https://github.com/zk-phi/symon/

And many others...

** Generation and Usage

=config.org= is the source file containing my preferences and settings. =config.el= and
=config.html= are generated from it.


#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (setq debug-on-error t)
  (require 'cl)
  (require 'org)
  (defun export-init-org ()
    "Generate init.html and init.html from the current init.org file."
    (interactive)
    (call-interactively 'org-babel-tangle)
    (call-interactively 'org-export-as-html)
    (call-interactively 'org-md-export-to-markdown))
#+END_SRC

** Licensing

Code I've written (this org file, init.el, and other files in this repository)
is MIT licensed.

** To Do

These are items I'm considering adding at a later date:

- https://github.com/chrisdone/god-mode
- https://github.com/nschum/highlight-symbol.el
- http://ternjs.net
- https://www.emacswiki.org/emacs/HideShow and https://www.emacswiki.org/emacs/download/hideshowvis.el

** Tried and removed
*** Agressive Indent

I liked this mode in certain instances, but it seemed to have problems when
editing files with more than 100 lines, and even made emacs lock-up a couple 
of times.

* Contents
** Basic Settings

Some very basic settings for my environment

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name "Phillip B Oldham"
      change-log-default-name "CHANGELOG")
#+END_SRC

** Performance

First-off, lets do some performance tweaks to keep things ticking along
nicely.

Emacs will run garbage collection after `gc-cons-threshold' bytes of
consing. The default value is 800,000 bytes, or ~ 0.7 MiB. By
increasing to 100 MiB we reduce the number of pauses due to
garbage collection during setup. I'll return this to the default
after setup.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq gc-cons-threshold 100000000)
#+END_SRC

Let's add some timestamps to the messages so we can see whether anything
is causing emacs to block for a significant amount of time.

#+BEGIN_SRC emacs-lisp :tangle yes
;;; timestamps in *Messages*
(defun current-time-microseconds ()
  (let* ((nowtime (current-time))
         (now-ms (nth 2 nowtime)))
    (concat (format-time-string "[%Y-%m-%dT%T" nowtime) (format ".%d] " now-ms))))

(defadvice message (before test-symbol activate)
  (if (not (string-equal (ad-get-arg 0) "%s%s"))
      (let ((deactivate-mark nil)
            (inhibit-read-only t))
        (with-current-buffer "*Messages*"
          (goto-char (point-max))
          (if (not (bolp))
              (newline))
          (insert (current-time-microseconds))))))
#+END_SRC

** Startup Tweaks

Stop the start screen from displaying
#+BEGIN_SRC emacs-lisp :tangle yes
(setq inhibit-startup-message t)
#+END_SRC

Hide the unused toolbar
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
#+END_SRC

Hide scrollbars
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+END_SRC

Kill the annoying bell
#+BEGIN_SRC emacs-lisp :tangle yes
(setq visible-bell t)
#+END_SRC

Disable the cursor blink
#+BEGIN_SRC emacs-lisp :tangle yes
(blink-cursor-mode -1)
#+END_SRC

Don't insert instructions in the *scratch* buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(setq initial-scratch-message nil)
#+END_SRC

Allow answering 'Yes or No' prompts with Y or N
#+BEGIN_SRC emacs-lisp :tangle yes
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Reduce the message log to 512 entries
#+BEGIN_SRC emacs-lisp :tangle yes
(setq message-log-max 512)
#+END_SRC

Stop warnings
#+BEGIN_SRC emacs-lisp :tangle yes
(setq byte-compile-warnings nil)
#+END_SRC

** Package Management
*** Sources

I use ELPA packages heavily for functionality, primarily the MELPA and Marmalade
repositories. Initalize all the package repos here, so we can use them later.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.milkbox.net/packages/") t)
(add-to-list 'package-archives '("marmalade" . "https://marmalade-repo.org/packages/") t)
(add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
(package-initialize)
#+END_SRC

Update the local package database if needed before installing packages
#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice package-install (before maybe-refresh-packages activate)
  (unless (or (called-interactively-p) (assq (ad-get-arg 0) package-archive-contents))
    (unless package--initialized
      (package-initialize t))
    (unless (and package-archive-contents (assq (ad-get-arg 0) package-archive-contents))
      (package-refresh-contents))))
#+END_SRC

*** =req-package=

=req-package= is a macro wrapper on top of use-package. It's goal is to simplify
package dependencies management.

#+BEGIN_SRC emacs-lisp :tangle yes
(unless (package-installed-p 'req-package)
  (package-install 'req-package))
(package-initialize)
(require 'req-package)
#+END_SRC

Automatically keep packages up to date.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package auto-package-update
             :init (auto-package-update-maybe))
#+END_SRC

This package also provides =bind-key=, which is really useful for managing
keybindings.

*** Diminish
diminish hides or abbreviates minor mode indicators in the modeline

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package diminish)
#+END_SRC

** Interface
*** Theme

I prefer a smaller font, to get more text onto the screen.

#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'default nil :font "Meslo LG L DZ for Powerline:pixelsize=10:weight=normal:slant=normal:width=normal:spacing=100:scalable=true")
#+END_SRC

I prefer darker themes as they're easier on my eyes, so I created one:
https://github.com/OldhamMade/leiptr-theme

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'custom-theme-load-path (expand-file-name "themes/leiptr" dotfiles-dir))
(load-theme 'leiptr t)
#+END_SRC

*** Line Numbers
Turn line-numbers on everywhere.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package hlinum
             :init
             (progn
               (global-linum-mode 1)
               (setq linum-format "%4d\u2595")
               (setq column-number-mode 1)
               (hlinum-activate)
               ))
#+END_SRC

Allow clicking the line-numbers to select the line(s)

#+BEGIN_SRC emacs-lisp :tangle yes
(defun line-at-click ()
  (save-excursion
  (let ((click-y (cdr (cdr (mouse-position))))
      (line-move-visual-store line-move-visual))
    (setq line-move-visual t)
    (goto-char (window-start))
    (next-line (1- click-y))
    (setq line-move-visual line-move-visual-store)
    (1+ (line-number-at-pos)))))

(defun md-select-linum ()
  (interactive)
  (goto-line (line-at-click))
  (set-mark (point))
  (setq *linum-mdown-line*
    (line-number-at-pos)))

(defun mu-select-linum ()
  (interactive)
  (when *linum-mdown-line*
  (let (mu-line)
    (setq mu-line (line-at-click))
    (goto-line (max *linum-mdown-line* mu-line))
    (set-mark (line-end-position))
    (goto-line (min *linum-mdown-line* mu-line))
    (setq *linum-mdown*
      nil))))

(bind-keys ("<left-margin> <down-mouse-1>" . md-select-linum)
           ("<left-margin> <mouse-1>" . mu-select-linum)
           ("<left-margin> <S-mouse-1>" . mu-select-linum)
           ("<left-margin> <drag-mouse-1>" . mu-select-linum))
#+END_SRC

*** Seeing changes when working with Git

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package git-gutter-fringe+
             :init
             (progn
               (require 'git-gutter-fringe+)
               (global-git-gutter+-mode)
               (git-gutter-fr+-minimal)
               (setq-default left-fringe-width  16
                             right-fringe-width 16)
               (eval-after-load "git-gutter+" '(diminish 'git-gutter+-mode))
               ))
#+END_SRC

*** Recursive Editing

We can make the minibuffer much more useful by enabling recursive
usage. This means that when the minibuffer is active we can still call
commands that require the minibuffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq enable-recursive-minibuffers t)
#+END_SRC

It's easy to lose track of whether we're in a recursive minibuffer or
not. We display the recursion level in the minibuffer to avoid confusion.

#+BEGIN_SRC emacs-lisp :tangle yes
  (minibuffer-depth-indicate-mode 1)
#+END_SRC

*** Uniquify buffer names

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package uniquify
             :init
             (progn
                (setq uniquify-buffer-name-style 'forward)
                ))
#+END_SRC

*** Modeline
I prefer the cleaner Powerline to the usual modeline.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package powerline
             :init (powerline-default-theme))
#+END_SRC

Reduce the amount of rubbish in the modeline...

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
  (lambda()
    (setq mode-name "el")))
#+END_SRC

*** Find convenient unbound keystrokes

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package unbound)
#+END_SRC

** Key bindings
*** Mac
Set Option as Meta, and add Cmd as "Hyper"

#+BEGIN_SRC emacs-lisp :tangle yes
(setq mac-command-modifier 'alt
      mac-option-modifier 'meta
      mac-command-modifier 'hyper)
#+END_SRC

Undo/redo

#+BEGIN_SRC emacs-lisp :tangle yes
(bind-keys* ("H-z" . undo)
            ("H-S-z" . redo)
            ("H-Z" . redo)
            ;; Select all
            ("H-a" . mark-whole-buffer)
            ;; cut
            ("H-x" . kill-region)
            ;; copy
            ("H-c" . kill-ring-save)
            ;; paste
            ("H-v" . yank)
            ;; open
            ("H-o" . find-file)
            ;; save
            ("H-s" . save-buffer)
            ;;  close
            ("H-w" . (lambda ()
                       (interactive)
                       (my-kill-buffer
                         (current-buffer))))
            ;; quit
            ("H-q" . save-buffers-kill-emacs)
            ;; maximise
            ("<f12>" . toggle-frame-fullscreen)
            ;; minimise
            ("H-m" . iconify-frame)
            ;; hide
            ("H-h" . ns-do-hide-emacs)
            ;; search
            ("H-f" . isearch-forward)
            ("H-g" . isearch-repeat-forward)
            ;; jump to beginning of line
            ("H-<left>" . beginning-of-line)
            ;; jump to end of line
            ("H-<right>" . end-of-line)
            ;; jump to top of file
            ("H-t" . beginning-of-buffer)
            ;; jump to bottom of file
            ("H-b" . end-of-buffer)
            ;; jump to line number
            ("H-C-l" . goto-line)
            ;; uppercase region
            ("H-u" . upcase-region)
            ;; lowercase region
            ("H-l" . downcase-region)
            ;; join a line with the previous one
            ;; and balance spaces
            ("H-S-<backspace>" . join-line)
            ;; Repeat the last command
            ("H-S-r" . repeat)
            ;; Use the Escape key to escape the keyboard
            ("<escape>" . keyboard-escape-quit)
            ;; Allow euro to be entered
            ("M-2" . (lambda ()
                       (interactive)
                       (insert "€")))
            ;; Allow hash to be entered
            ("M-3" . (lambda ()
                       (interactive)
                       (insert "#")))
            ;; make text larger
            ("H-=" . text-scale-increase)
            ;; make text smaller
            ("H--" . text-scale-decrease)
            ;; prefer ibuffer
            ("C-x C-b" . ibuffer)
            )
#+END_SRC

*** Key chords

I like to set up a number of key-chords that work well for my natural
hand placement on my macbook's keyboard, aiming for combos that won't
generally be activated accidentally during typing (I type quite fast).

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/key-chord-mode-hook ()
  (when (memq window-system '(mac ns))
    (key-chord-define-global "§1" 'toggle-frame-fullscreen))
  (key-chord-define-global "o0" 'find-file)
  (key-chord-define-global "o=" 'dired-jump)
  (key-chord-define-global "o-" 'ido-recentf-open)
  (key-chord-define-global "o[" 'find-file-at-point)
  (key-chord-define-global "o;" 'occur)
  (key-chord-define-global "p-" 'projectile-find-file)
  (key-chord-define-global "t5" 'untabify)
  (key-chord-define-global "r4" 'replace-string)
  (key-chord-define-global "r3" 'vr/query-replace)
  (key-chord-define-global "e3" 'er/expand-region)
  (key-chord-define-global "e2" 'er/contract-region)
  (key-chord-define-global "p[" 'fill-paragraph)
  (key-chord-define-global "p]" 'unfill-paragraph)
  (key-chord-define-global " k" 'delete-trailing-whitespace)
  (key-chord-define-global "m," 'my-previous-like-this)
  (key-chord-define-global "m." 'my-more-like-this)
  (key-chord-define-global "s1" 'ispell-region)
  (key-chord-define-global "bk" 'bm-toggle)
  (key-chord-define-global "bn" 'bm-next)
  (key-chord-define-global "bv" 'bm-previous)
  (key-chord-define-global "d3" 'dash-at-point)
  (key-chord-define-global "R$" 'rgrep)
)
(req-package key-chord
             :defer t
             :init
             (progn
               (key-chord-mode 1)
               (my/key-chord-mode-hook)
               ))
#+END_SRC

*** Hydra
Hydra is a package that can be used to tie related commands
into a family of short bindings with a common prefix.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package 'hydra)
#+END_SRC

** Auto-completion (Company mode)

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package company-quickhelp
             :requires (company-mode company-jedi)
             :defer t
             :init
             (progn
               (global-company-mode 1)
               (company-quickhelp-mode 1)
               (setq company-idle-delay 0.2)
               (bind-key "\t" 'company-complete-common company-mode-map)
               ))
#+END_SRC

** Highlighting
*** Highlight syntax

Turn syntax highlighting on by default

#+BEGIN_SRC emacs-lisp :tangle yes
(global-font-lock-mode 1)
#+END_SRC

*** Highlight indentation

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package highlight-indentation
			 :config (set-face-background 'highlight-indentation-face "#222")
             :init
             (progn
               (add-hook 'prog-mode-hook 'highlight-indentation-mode)
               (add-hook 'yaml-mode-hook 'highlight-indentation-mode)
               ))
#+END_SRC

*** Highlight delimiters

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package rainbow-delimiters
             :diminish ""
             :init
             (progn
               (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
               (add-hook 'sass-mode-hook 'rainbow-delimiters-mode)
               ))
#+END_SRC

*** Highlight variables

Rainbow identifiers subtly changes the look of variables, to make them a little
easier to visually search

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package rainbow-identifiers
			 :init (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
(req-package column-enforce-mode
			 :diminish column-enforce-mode
             :init
             (progn
               (add-hook 'python-mode-hook 'column-enforce-mode)
               (add-hook 'alchemist-mode-hook 'column-enforce-mode)
               ))
#+END_SRC

*** Highlight colour references with it's colour

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package rainbow-mode
             :defer t
             :init
             (progn
               (add-hook 'clevercss-mode-hook 'rainbow-mode)
               (add-hook 'less-mode-hook 'rainbow-mode)
               (add-hook 'css-mode-hook 'rainbow-mode)
               (add-hook 'css-mode-hook 'rainbow-mode)
               (add-hook 'emacs-lisp-mode-hook 'rainbow-mode)
               ))
#+END_SRC

*** Highlight fill-column

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default fci-rule-column 79)
(setq-default fci-rule-character-color "red3")
(setq fci-rule-width 1)
(setq fci-rule-color "gray10")
(add-hook 'after-change-major-mode-hook 'fci-mode)
#+END_SRC

** Buffers
*** Initial buffer major mode: text

#+BEGIN_SRC emacs-lisp :tangle yes
(setq initial-major-mode 'text-mode)
#+END_SRC

*** New Empty Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(defun new-empty-buffer ()
  "Create a new buffer called untitled(<n>)"
  (interactive)
  (let ((newbuf (generate-new-buffer-name "untitled")))
    (switch-to-buffer newbuf)))

(bind-key* "H-n" 'new-empty-buffer)
#+END_SRC

*** Scratch buffer management

Now let's make the *scratch* buffer persistent across sessions

#+BEGIN_SRC  emacs-lisp :tangle yes
(req-package persistent-scratch
             :defer t
             :init
             (progn
               (persistent-scratch-setup-default)
               ))

(defun my/set-scratch-as-text ()
  (with-current-buffer (get-buffer "*scratch*")
    (let ((mode "text-mode"))
      (message "Setting scratch to text-mode")
      (funcall (intern mode)))))

(defadvice persistent-scratch-restore (after advice-persistent-scratch-restore activate)
  (my/set-scratch-as-text))

;; yas-reload-all unfortunately triggers `persistent-scratch-setup-default`
;; again, resetting the scratch to fundamental-mode, so advising here too.
;; (defadvice yas-reload-all (after advice-yas-reload-all activate)
;;  (my/set-scratch-as-text))
#+END_SRC

*** Persist certain buffers

Bury certain buffers instead of kill them

#+BEGIN_SRC emacs-lisp :tangle yes
(setq bury-buffer-names '("*scratch*" "*Messages*"))

(defun kill-buffer-query-functions-maybe-bury ()
  "Bury certain buffers instead of killing them."
  (if (member (buffer-name (current-buffer)) bury-buffer-names)
      (progn
        (kill-region (point-min) (point-max))
        (bury-buffer)
        nil)
    t))

(add-hook 'kill-buffer-query-functions 'kill-buffer-query-functions-maybe-bury)

(defun my-kill-buffer (buffer)
  "Protect some special buffers from getting killed."
  (interactive (list (current-buffer)))
  (if (member (buffer-name buffer) bury-buffer-names)
      (call-interactively 'bury-buffer buffer)
    (kill-buffer buffer)))
#+END_SRC

*** Kill all buffers except current

#+BEGIN_SRC emacs-lisp :tangle yes
(defun kill-all-buffers-except-current ()
  "Kill all buffers except current buffer."
  (interactive)
  (let ((current-buf (current-buffer)))
    (dolist (buffer (buffer-list))
      (set-buffer buffer)
      (unless (eq current-buf buffer)
        (kill-buffer buffer)))))
#+END_SRC

*** Switching buffers
#+BEGIN_SRC emacs-lisp :tangle yes
(defun custom-ignore-buffer (str)
  (or
   ;;buffers I don't want to switch to
   (string-match "\\*Buffer List\\*" str)
   (string-match "\\*Compile-Log\\*" str)
   (string-match "^TAGS" str)
   (string-match "^\\*Messages\\*$" str)
   (string-match "^\\*Completions\\*$" str)
   (string-match "^\\*Flymake error messages\\*$" str)
   (string-match "^\\*Flycheck error messages\\*$" str)
   (string-match "^\\*SPEEDBAR\\*" str)
   (string-match "^ " str)

   ;;Test to see if the window is visible on an existing visible frame.
   ;;Because I can always ALT-TAB to that visible frame, I never want to
   ;;Ctrl-TAB to that buffer in the current frame.  That would cause
   ;;a duplicate top-level buffer inside two frames.
   (memq str
         (mapcar
          (lambda (x)
            (buffer-name
             (window-buffer
              (frame-selected-window x))))
          (visible-frame-list)))
   ))

(defun custom-switch-buffer (ls)
  "Switch to next buffer in ls skipping unwanted ones."
  (let* ((ptr ls)
         bf bn go
         )
    (while (and ptr (null go))
      (setq bf (car ptr)  bn (buffer-name bf))
      (if (null (custom-ignore-buffer bn))        ;skip over
   (setq go bf)
        (setq ptr (cdr ptr))
        )
      )
    (if go
        (switch-to-buffer go))))

(defun custom-prev-buffer ()
  "Switch to previous buffer in current window."
  (interactive)
  (custom-switch-buffer (reverse (buffer-list))))

(bind-key "H-<down>" 'custom-prev-buffer)

(defun custom-next-buffer ()
  "Switch to the other buffer (2nd in list-buffer) in current window."
  (interactive)
  (bury-buffer (current-buffer))
  (custom-switch-buffer (buffer-list)))

(bind-key "H-<up>" 'custom-next-buffer)
#+END_SRC

*** Copy buffer path to kill ring

#+BEGIN_SRC emacs-lisp :tangle yes
(defun copy-full-path-to-kill-ring ()
  "copy buffer's full path to kill ring"
  (interactive)
  (when buffer-file-name
    (kill-new (file-truename buffer-file-name))))
#+END_SRC

*** Echo buffer path

#+BEGIN_SRC emacs-lisp :tangle yes
(defun describe-variable-short (var)
  (interactive "vVariable: ")
  (message (format "%s: %s" (symbol-name var) (symbol-value var))) )

(defun get-buffer-path ()
  "print the buffer path in the mini buffer"
  (interactive)
  (when buffer-file-name
    (kill-new (file-truename buffer-file-name))
    (message (format "Path: %s (copied to kill-ring)" (file-truename buffer-file-name)))
    ))
#+END_SRC

** Files
*** Copy Filename to Clipboard

#+BEGIN_SRC emacs-lisp :tangle yes
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC

*** Open Filename with External Program

#+BEGIN_SRC emacs-lisp :tangle yes
(defun open-with ()
  "Simple function that allows us to open the underlying
file of a buffer in an external program."
  (interactive)
  (when buffer-file-name
    (shell-command (concat
                    (if (eq system-type 'darwin)
                        "open"
                      (read-shell-command "Open current file with: "))
                    " "
                    buffer-file-name))))
#+END_SRC

*** Reveal in Finder
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package reveal-in-osx-finder)
#+END_SRC
*** Rename File and Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(defun rename-file-and-buffer ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)))))))
#+END_SRC

*** Move File and Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(defun move-buffer-file (dir)
  "Move both current buffer and file it's visiting to DIR."
  (interactive "DNew directory: ")
  (let* ((name (buffer-name))
         (filename (buffer-file-name))
         (dir
          (if (string-match dir "\\(?:/\\|\\\\)$")
              (substring dir 0 -1) dir))
         (newname (concat dir "/" name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (copy-file filename newname 1)
      (delete-file filename)
      (set-visited-file-name newname)
      (set-buffer-modified-p nil)
      t)))
#+END_SRC

*** Reloading
Always reload the file on disk when it updates

#+BEGIN_SRC emacs-lisp :tangle yes
(global-auto-revert-mode 1)
#+END_SRC

*** Autosaves and Backups

Autosaving of files

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-save-file-name-transforms `((".*" , "~/.emacs.d/auto-save" t)))
#+END_SRC

Backup files to a local directory.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq backup-by-copying t)
(setq backup-directory-alist '(("" . "~/.emacs.d/auto-backup")))
#+END_SRC

*** Saving

Always append a new line to the file

#+BEGIN_SRC emacs-lisp :tangle yes
(setq require-final-newline t)
#+END_SRC

Clean whitespace intelligently on save

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package whitespace-cleanup-mode
			 :diminish whitespace-cleanup-mode
             :init (global-whitespace-cleanup-mode))
#+END_SRC

*** Deletion
Make the dired function `delete-by-moving-to-trash` work correctly on OS X
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package osx-trash
			 :diminish ""
             :init 
             (progn
               (when (eq system-type 'darwin)
                 (osx-trash-setup))
               (setq delete-by-moving-to-trash t)
               ))
#+END_SRC
** Navigation
*** Minibuffer Shortcuts
When selecting a file to visit, // will mean /
and ~ will mean $HOME regardless of preceding text

#+BEGIN_SRC emacs-lisp :tangle yes
(setq file-name-shadow-tty-properties '(invisible t))
(file-name-shadow-mode 1)
#+END_SRC

*** Open recently opened files quickly

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package recentf
             :init
             (progn
               (recentf-mode 1)
               (setq recentf-max-save-items 500
                     recentf-max-menu-items 100)
               (add-to-list 'recentf-exclude "ido\\.last\\'")
               (recentf-cleanup)
             ))
#+END_SRC

*** IDO

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package ido-ubiquitous
             :require (ido recentf)
             :init
             (progn
               (ido-mode t)
               (setq ido-confirm-unique-completion nil)
               (setq ido-create-new-buffer 'always)
               (setq ido-enable-flex-matching t)
               (setq ido-ignore-extensions t)
               (setq ido-use-virtual-buffers t)
               (ido-ubiquitous-mode 1)
               ))
#+END_SRC

Flx is rather useful, so let's add that too

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package flx-ido
             :require flx
             :init
             (progn
               (flx-ido-mode 1)
               ))
#+END_SRC

Use ido for recently open files

#+BEGIN_SRC emacs-lisp :tangle yes
(defun ido-recentf-open ()
  "Use `ido-completing-read' to \\[find-file] a recent file"
  (interactive)
  (if (find-file (ido-completing-read "Find recent file: " recentf-list))
      (message "Opening file...")
    (message "Aborting")))

(bind-key "H-S-o" 'ido-recentf-open)
#+END_SRC

*** Smex

Improve M-x with recent/popular commands at prompt.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package smex
             :bind (("M-x" . smex)
                    ("M-X" . smex-major-mode-commands)
                    ("C-c C-c M-x" . execute-extended-command)))
#+END_SRC

*** Projectile

Automagically interact with "projects"; git, mercurial, bazaar, and darcs repos
are seen as projects by default.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package projectile
             :diminish ""
             :init
             (progn
               (projectile-global-mode)
               ))
#+END_SRC

** Moving Around
*** By indentation

`C-a' normally moves us to the beginning of the line
unconditionally. This version is more useful, as it moves to the
first non-whitespace character if we're already at the beginning of
the line. Repeated use of `C-a' toggles between these two positions.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun beginning-of-line-dwim ()
    "Toggles between moving point to the first non-whitespace character, and
  the start of the line."
    (interactive)
    (let ((start-position (point)))
      (move-beginning-of-line nil)
      (when (= (point) start-position)
          (back-to-indentation))))

  (bind-keys
    ("C-a" . beginning-of-line-dwim)
    ("H-<left>" . beginning-of-line-dwim))
#+END_SRC

*** By last change

It can be rather handy to jump to the last changed area in a file.

KEYBINDING: "M -"

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package goto-last-change
             :diminish ""
             :bind ("H-M-<left>" . goto-last-change))
#+END_SRC

*** Avy
Avy is a package for jumping to visible text using a char-based decision tree

KEYBINDING: "C-H-j"

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package avy
             :diminish ""
             :init
             (progn
               (defhydra hydra-avy (:color blue)
                 "avy-goto"
                 ("j" avy-goto-char "char")
                 ("k" avy-goto-char-2 "char-2")
                 ("l" avy-goto-line "line")
                 ("q" nil "quit"))
               (bind-key "C-H-j" 'hydra-avy/body)
               ))
#+END_SRC

*** Bookmarks
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package bm
             :diminish ""
             :bind (("C-b m" . bm-toggle)
                    ("C-b n" . bm-next)
                    ("C-b p" . bm-previous)
                    ("H->" . bm-next)
                    ("H-<" . bm-previous)))
#+END_SRC
*** Jump-to-definition
#+begin_src emacs-lisp :tangle yes
(req-package dumb-jump
             :diminish ""
             :defer t
             :bind (("H-j" . dumb-jump-go)
                    ("H-S-j" . dumb-jump-back)
                    ("H-M-j" . dumb-jump-quick-look))
             :init
             (progn
               (setq dumb-jump-default-project "~/Projects")))
#+END_SRC

** Editing
*** Showing changes
Highlight changes to the buffer caused by commands such as ‘undo’, ‘yank’/’yank-pop’, etc.

Note: disabled for now, as it interacts badly with cua-paste

#+BEGIN_SRC emacs-lisp :tangle no
(req-package volatile-highlights
             :defer t
             :diminish volatile-highlights-mode
             :init (volatile-highlights-mode t))
#+END_SRC

*** Tabs

Since I generally develop with languages that adhere to the "off-side" rule
(eg, Python) always replace tabs with spaces.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default indent-tabs-mode nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(electric-indent-mode +1)
#+END_SRC

Set tab width to 4 for all buffers

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default tab-width 4)
#+END_SRC

*** Overwriting

When there's an active selection, delete on inserting new text (overwrite)

#+BEGIN_SRC emacs-lisp :tangle yes
(delete-selection-mode +1)
#+END_SRC

*** Undo
Standard Emacs undo is kind of confusing. [[http://www.dr-qubit.org/emacs.php#undo-tree][undo-tree]] replaces this with a
simpler tree structure. It also allows us to visualize the tree directly.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package undo-tree
             :ensure undo-tree
             :diminish ""
             :init (global-undo-tree-mode))
#+END_SRC

*** CUA

Enable CUA mode for using =C-RET= for working with rectangles.

#+BEGIN_SRC emacs-lisp :tangle yes
(cua-mode)
(setq cua-enable-cua-keys nil
      cua-remap-control-v nil
      cua-highlight-region-shift-only t
      cua-toggle-set-mark nil)

(setq-default cua-enable-cua-keys nil
              cua-highlight-region-shift-only t
              cua-toggle-set-mark nil)

;; re-bind H-v to yank, as cua-paste breaks other modes
(global-unset-key (kbd "H-v"))
(define-key cua-global-keymap (kbd "H-v") nil)
(define-key cua-global-keymap [remap cua-paste] 'yank)
(bind-keys* ("H-v" . yank))

;; shift + click select region
(define-key global-map (kbd "<S-down-mouse-1>") 'ignore) ; turn off font dialog
(define-key global-map (kbd "<S-mouse-1>") 'mouse-set-point)
(put 'mouse-set-point 'CUA 'move)
#+END_SRC

#--- +BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path (expand-file-name "custom/cua-lite" dotfiles-dir))
(require 'cua-lite)
;; (cua-lite 1)
#--- +END_SRC

Transient-mark-mode needs to be reenabled after enabling CUA-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(setq transient-mark-mode t)
#+END_SRC

*** Auto-pair braces

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package autopair
             :diminish autopair-mode
             :init
             (progn
              (autopair-global-mode)
              (setq show-paren-delay 0
                    show-paren-style 'parenthesis)
              (show-paren-mode t)
              (add-hook 'term-mode-hook
                        #'(lambda ()
                            (setq autopair-dont-activate t)
                            (autopair-mode -1)))
              ))
#+END_SRC

*** Sort lines, case insensitive

#+BEGIN_SRC emacs-lisp :tangle yes
(defun sort-lines-nocase ()
  (interactive)
  (let ((sort-fold-case t))
    (call-interactively 'sort-lines)))
#+END_SRC

*** Fix/replace "Smart Quotes"

#+BEGIN_SRC emacs-lisp :tangle yes
(defun fix-smart-quotes (beg end)
  "Replace 'smart quotes' in buffer or region with ascii quotes."
  (interactive "r")
  (format-replace-strings '(("\x201C" . "\"")
                            ("\x201D" . "\"")
                            ("\x2018" . "'")
                            ("\x2019" . "'"))
                          nil beg end))
#+END_SRC

*** Remove ^M

#+BEGIN_SRC emacs-lisp :tangle yes
(defun remove-control-m ()
  (interactive)
  (goto-char 1)
  (while (search-forward "
" nil t)
    (replace-match "" t nil)))
#+END_SRC

*** Unfill paragraph

Unfill functions providing the inverse of fill-paragraph and fill-region

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package unfill)
#+END_SRC

*** Browse Kill Ring

KEYBINDING: "M y"

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package browse-kill-ring
             :init (browse-kill-ring-default-keybindings))
#+END_SRC

*** Remote editing via tramp

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package tramp
             :init (setq tramp-default-method "ssh"))
#+END_SRC

*** Expand region
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package expand-region)
#+END_SRC

*** Multiple Cursors
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package multiple-cursors)
#+END_SRC

** Search/replace
*** Showing search results
Display 'current match/total matches' in the mode-line in various search modes

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package anzu
             :diminish anzu-mode
             :init (global-anzu-mode +1))
#+END_SRC

*** Regex search/replace
I'm not a big fan of the regular expression syntax in emacs,
so install visual-regexp-steroids to use Python's regex model.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package visual-regexp-steroids
             :require (visual-regexp)
             :bind (("C-c r" . vr/replace)
                    ("C-c q" . vr/query-replace)
                    ("C-r" . vr/isearch-backward)
                    ("C-s" . vr/isearch-forward)))
#+END_SRC

*** Occur
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package occur-x
  :init 
    (progn
      (setq occur-linenumbers-in-margin 1)
      (add-hook 'occur-mode-hook 'turn-on-occur-x-mode)
      ))
#+END_SRC

** Windows
*** Recover window split with winner-mode
Enable C-c <left> to get back the previous window split

#+BEGIN_SRC emacs-lisp :tangle yes
(winner-mode 1)
#+END_SRC

*** Jumping between windows

Allow switching between windows with CTRL+Tab

#+BEGIN_SRC emacs-lisp :tangle yes
(bind-key "C-<tab>" 'other-window)
#+END_SRC

*** Mimic tmux

I use tmux a lot, and often find when I switch back to emacs
that I use the tmux pane-switch command from muscle memory.

#+BEGIN_SRC emacs-lisp :tangle yes
(unbind-key "\C-b")
(bind-keys* ("C-b <down>" . other-window)
            ("C-b <up>" . previous-multiframe-window))
#+END_SRC

** Org-mode
*** Fix keybindings
Allow indenting natively within source blocks.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-src-tab-acts-natively t)
#+END_SRC

Org-mode has some very annoying keybindings, which interfere with my preferred keybindings.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'org-mode-hook
  (lambda()
    (local-unset-key (kbd "C-<tab>")) ; allow switching between frames
    ))
#+END_SRC

I like to shift-select things, so enable that.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-support-shift-select 'always)
#+END_SRC

*** Bullets
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package org-bullets
             :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

*** Todo

Add font styles to DONE lines.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-fontify-done-headline t)
#+END_SRC

** Programming
*** Common
**** Enable CamelCase awareness for all programming modes
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'subword-mode)
(eval-after-load "subword" '(diminish 'subword-mode))
#+END_SRC
**** Better commenting
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package comment-dwim-2
             :bind  (("M-;" . comment-dwim-2)))
#+END_SRC
**** Automated white-space cleanup
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package whitespace-cleanup-mode
             :defer t
             :init (global-whitespace-cleanup-mode t))
#+END_SRC

*** Dash
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package dash-at-point)
#+END_SRC

*** Flycheck

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package flycheck
             :require (dash s f exec-path-from-shell flycheck-color-mode-line)
             :ensure flycheck
             :diminish (flycheck-mode . " ✓ ")
             :config (add-hook 'after-init-hook 'global-flycheck-mode)
             :defer t
             :init
             (progn
               (add-hook 'after-init-hook 'global-flycheck-mode)
               (eval-after-load "flycheck"
                 '(add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
               ))
#+END_SRC

*** General
**** Python

A hydra for testing with nose.

#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-nosetest (:color blue)
  "nosetest"
  ("t" nosetests-all "test all")
  ("m" nosetests-module "module")
  ("o" nosetests-one "one")
  ("a" nosetests-again "again")
  ("q" nil "cancel"))
#+END_SRC

Install elpy for working with Python, with the =jedi= backend, and nose.

#+BEGIN_SRC emacs-lisp :tangle yes
#+END_SRC
(req-package elpy
             :init
             (progn
               (setq elpy-rpc-backend "jedi")
              ))

               # ; (setq python-fill-docstring-style 'symmetric)
#                ;(when (executable-find "ipython")
#                ;  (elpy-use-ipython))
#                ;(nose-mode t)
#                ;(bind-keys :map elpy-mode-map
#                ;           ("M-<left>" . nil)
#                ;           ("M-<right>" . nil)
#                ;           ("C-M-<left>" . elpy-nav-indent-shift-left)
#                ;           ("C-M-<right>" . elpy-nav-indent-shift-right)
#                ;           ("C-c n" . hydra-nosetest/body))

# TODO: add `python-docstring-mode` to requirements for elpy
#              :require (nose)

Enable company mode auto-completion backend for python, and some
custom key-bindings

(defun python-backtab ()
  (interactive)
  (if mark-active
      (let (deactivate-mark)
        (python-indent-shift-left (region-beginning) (region-end)))))

(defun python-tab ()
  (interactive)
  (if mark-active
      (let (deactivate-mark)
        (python-indent-shift-right (region-beginning) (region-end)))
    (indent-for-tab-command)))

(defun python-backtab ()
  (interactive)
  (if mark-active
      (let (deactivate-mark)
        (python-indent-shift-left (region-beginning) (region-end)))))

(defun python-tab ()
  (interactive "^")
  (python-indent-shift-right 1)
  (back-to-indentation))

(defadvice python-indent-shift-right (after python-indent-shift-right activate)
  (back-to-indentation))


#+BEGIN_SRC emacs-lisp :tangle yes
(defun pyfile-overview ()
  (interactive)
  (occur "class \\\|def "))

(defun my/python-mode-hook ()
  (elpy-enable)
  (bind-keys :map python-mode-map
             ("<tab>" . elpy-nav-indent-shift-right)
             ("<backtab>" . elpy-nav-indent-shift-left)))
(add-hook 'python-mode-hook 'my/python-mode-hook)
#+END_SRC

  (elpy-enable)
  (with-eval-after-load 'company-mode
    (add-to-list 'company-backends 'company-jedi)
    (company-mode)))

  # ;(with-eval-after-load 'company-mode
  #   ;(bind-keys :map elpy-mode-map
  #   ;           ("<tab>" . python-indent-shift-right)
  #   ;           ("S-<tab>" . python-indent-shift-left))
  #   ;(add-to-list 'company-backends 'company-jedi)
  #   ;(company-mode)
  #   ;(python-docstring-mode)
  #   ;
  #   ;))

  # (bind-keys :map python-mode-map
  #            ("M-<left>" . nil)
  #            ("M-<right>" . nil)
  #            ("C-M-<left>" . elpy-nav-indent-shift-left)
  #            ("C-M-<right>" . elpy-nav-indent-shift-right)
  #            ("<tab>" . elpy-nav-indent-shift-right)
  #            ("<backtab>" . elpy-nav-indent-shift-left)))

  # (setq electric-indent-chars (delq ?: electric-indent-chars))

I occasionally use Jinja for templating, so let's add that mode too.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package jinja2-mode
             :diminish ""
             :mode ("\\.jinja2?\\'" . jinja2-mode))
#+END_SRC

Add =cython-mode= for working with Cython files.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package cython-mode)
#+END_SRC

**** Elixir
Adding Alchemist for elixir programming.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package ruby-end)
(req-package alchemist
             :requires (elixir-mode)
             :defer t
             :mode ("\\.exs\\'" . alchemist-mode))

(add-hook 'elixir-mode-hook 'alchemist-mode)
(add-hook 'elixir-mode-hook 'company-mode)
(add-hook 'elixir-mode-hook
          (lambda ()
            (set (make-variable-buffer-local 'ruby-end-expand-keywords-before-re)
                 "\\(?:^\\|\\s-+\\)\\(?:do\\)")
            (set (make-variable-buffer-local 'ruby-end-check-statement-modifiers)
                 nil)
            (ruby-end-mode 1)))
#+END_SRC
**** Haskell
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package haskell-mode
             :defer t
             :mode ("\\.l?hs\\'" . haskell-mode))
#+END_SRC
**** Nim
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package nim-mode
             :defer t
             :mode ("\\.nim\\'" . nim-mode)
             :init
             (progn
; (add-to-list 'company-backends
;                '(company-nim :with company-nim-builtin))
))
#+END_SRC
*** Web
**** HTML et al
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package web-mode
             :defer t)

(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))

;; use eslint with web-mode for jsx files
(with-eval-after-load 'flycheck
  (flycheck-add-mode 'javascript-eslint 'web-mode))

;; adjust indents for web-mode to 2 spaces
(defun my-web-mode-hook ()
  "Hooks for Web mode. Adjust indents"
  ;;; http://web-mode.org/
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))

(add-hook 'web-mode-hook  'my-web-mode-hook)
#+END_SRC

**** JavaScript
Adding JavaScript
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package js2-mode
             :require (ac-js2 json-mode)
             :init
             (progn
               ;; disable jshint since we prefer eslint checking
               (setq-default flycheck-disabled-checkers
                 (append flycheck-disabled-checkers
                   '(javascript-jshint)))

               ;; disable json-jsonlist checking for json files
               (setq-default flycheck-disabled-checkers
                 (append flycheck-disabled-checkers
                   '(json-jsonlist)))

               (setq-default js-indent-level 2)
               (setq-default js2-basic-offset 2)
               (add-hook 'js-mode-hook 'js2-minor-mode)
               (add-hook 'js2-mode-hook 'ac-js2-mode)
               (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
               (add-to-list 'auto-mode-alist '("\\.jsx?\\'" . js2-jsx-mode))

               ;; for better jsx syntax-highlighting in web-mode
               ;; - courtesy of Patrick @halbtuerke
               (defadvice web-mode-highlight-part (around tweak-jsx activate)
                 (if (equal web-mode-content-type "jsx")
                   (let ((web-mode-enable-part-face nil))
                     ad-do-it)
                   ad-do-it))

               ))
#+END_SRC
**** CoffeeScript
Adding CoffeeScript
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package coffee-mode)
#+END_SRC
**** LiveScript
Adding LiveScript
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package livescript-mode)
#+END_SRC
**** Elm

Adding elm for front-end stuff

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package elm-mode
             :requires (flycheck-elm))
;(eval-after-load 'flycheck
;    '(add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
(with-eval-after-load 'company
  (add-to-list 'company-backends 'company-elm))
(add-hook 'elm-mode-hook 'company-mode)
(add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
#+END_SRC

**** Utilities
***** YASnippet
disabled for now
#+BEGIN_SRC emacs-lisp :tangle yes
#+END_SRC
(req-package yasnippet
             :init (yas-global-mode 1))

***** Mocha (Testing)
Add the ability to run tests from emacs. Also add some snippets to make writing tests quicker.
#-+BEGIN_SRC emacs-lisp :tangle yes
;(req-package mocha
;             :requires (mocha-snippets))
#-+END_SRC
** Markup
*** Sass/Scss
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package sass-mode
             :requires (flycheck-sass))
#+END_SRC
*** Less
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package less-css-mode
             :requires (flycheck-less))
#+END_SRC
*** Yaml
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package yaml-mode
             :requires (flycheck-yaml))
(add-to-list 'auto-mode-alist '("\\.raml\\'" . yaml-mode))
#+END_SRC
*** Markdown
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package markdown-mode
             :requires (flycheck-markdown))
#+END_SRC
*** Docker
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package dockerfile-mode)
#+END_SRC
** Terminal
*** Multi-term

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package multi-term
             :init
             (progn
               (setq multi-term-program "/bin/zsh")
               ))
#+END_SRC

*** Misc fixes

#+BEGIN_SRC emacs-lisp :tangle yes
(setq term-scroll-show-maximum-output 1)
(setq system-uses-terminfo nil)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
(add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
#+END_SRC

** Finalising
*** Kick-off the package install.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package-finish)
#+END_SRC

*** Set default gc

Now everything is set up, I want to return the gc level
back to the default to make the UI more responsive

#+BEGIN_SRC emacs-lisp :tangle yes
(setq gc-cons-threshold 800000)
#+END_SRC

I also want to make sure any minibuffer operations
don't trigger the gc, so tools like flx won't pause.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold 800000))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
#+END_SRC

