#+TITLE: Emacs Configuration
#+AUTHOR: Phillip B Oldham

* Introduction

This is the Emacs environment I (Phillip B Oldham, Oldham-Made) use for
development. This file is a literate programming document written with org-mode
and org-mode-babel. You can view config.org in a web browser on GitHub, or read
config.org directly in Emacs.

I generally only use Emacs on OS X, so there is a lot of customization around that OS.

Inspiration has been taking from the following sources:

- http://www.wilfred.me.uk/.emacs.d/init.org
- http://dl.dropboxusercontent.com/u/3968124/sacha-emacs.html
- https://github.com/jhenahan/emacs.d/blob/master/init.org
- https://github.com/zk-phi/symon/

And many others...

** Generation and Usage

=config.org= is the source file containing my preferences and settings. =config.el= and
=config.html= are generated from it.


#+BEGIN_SRC emacs-lisp :tangle yes
(setq debug-on-error t)
(require 'cl)
(require 'org)
(defun export-init-org ()
  "Generate init.html and init.html from the current init.org file."
  (interactive)
  (call-interactively 'org-babel-tangle)
  (call-interactively 'org-export-as-html)
  (call-interactively 'org-md-export-to-markdown))
#+END_SRC

** Licensing

Code I've written (this org file, init.el, and other files in this repository)
is MIT licensed.

** To Do

These are items I'm considering adding at a later date:

- https://github.com/chrisdone/god-mode
- https://github.com/nschum/highlight-symbol.el
- http://ternjs.net
- https://www.emacswiki.org/emacs/HideShow and https://www.emacswiki.org/emacs/download/hideshowvis.el

Crystal yasnippets:
ms - macro statement
mp - macro print
md - macro debug

** Tried and removed
*** Agressive Indent

I liked this mode in certain instances, but it seemed to have problems when
editing files with more than 100 lines, and even made emacs lock-up a couple 
of times.

* Contents
** Basic Settings

Some very basic settings for my environment

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name "Phillip B Oldham"
      change-log-default-name "CHANGELOG")
#+END_SRC

** Performance

First-off, lets do some performance tweaks to keep things ticking along
nicely.

Emacs will run garbage collection after `gc-cons-threshold' bytes of
consing. The default value is 800,000 bytes, or ~ 0.7 MiB. By
increasing to 100 MiB we reduce the number of pauses due to
garbage collection during setup. I'll return this to the default
after setup.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq gc-cons-threshold (* 200 1000 1000))
#+END_SRC

Let's add some timestamps to the messages so we can see whether anything
is causing emacs to block for a significant amount of time.

#+BEGIN_SRC emacs-lisp :tangle yes
;;; timestamps in *Messages*
(defun current-time-microseconds ()
  (let* ((nowtime (current-time))
         (now-ms (nth 2 nowtime)))
    (concat (format-time-string "[%Y-%m-%dT%T" nowtime) (format ".%d] " now-ms))))

(defadvice message (before test-symbol activate)
  (if (not (string-equal (ad-get-arg 0) "%s%s"))
      (let ((deactivate-mark nil)
            (inhibit-read-only t))
        (with-current-buffer "*Messages*"
          (goto-char (point-max))
          (if (not (bolp))
              (newline))
          (insert (current-time-microseconds))))))
#+END_SRC

** Startup Tweaks

Stop the start screen from displaying
#+BEGIN_SRC emacs-lisp :tangle yes
(setq inhibit-startup-message t)
#+END_SRC

Hide the unused toolbar
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
#+END_SRC

Hide scrollbars
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+END_SRC

Kill the annoying bell
#+BEGIN_SRC emacs-lisp :tangle yes
(setq visible-bell t)
#+END_SRC

Disable the cursor blink
#+BEGIN_SRC emacs-lisp :tangle yes
(blink-cursor-mode -1)
#+END_SRC

Don't insert instructions in the *scratch* buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(setq initial-scratch-message nil)
#+END_SRC

Allow answering 'Yes or No' prompts with Y or N
#+BEGIN_SRC emacs-lisp :tangle yes
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Reduce the message log to 512 entries
#+BEGIN_SRC emacs-lisp :tangle yes
(setq message-log-max 512)
#+END_SRC

Stop warnings
#+BEGIN_SRC emacs-lisp :tangle yes
(setq byte-compile-warnings nil)
#+END_SRC

Remove tab bar from macos

#+BEGIN_SRC emacs-lisp :tangle yes
(when (memq window-system '(mac ns))
  (mac-toggle-tab-bar nil))
#+END_SRC

Tell the world we're inside emacs

#+BEGIN_SRC emacs-lisp :tangle yes
(setenv "INSIDE_EMACS" "1")
#+END_SRC

** Package Management
*** Custom config

I don't like how package details are written to init.el,
so I stop that from happening with the following override:

#+BEGIN_SRC emacs-lisp :tangle yes
(defun package--save-selected-packages (&rest opt) nil)
#+END_SRC

*** Sources

I use ELPA packages heavily for functionality, primarily the MELPA and Marmalade
repositories. Initalize all the package repos here, so we can use them later.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq package-enable-at-startup nil)
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("marmalade" . "https://marmalade-repo.org/packages/")))

(require 'package)
#+END_SRC

Update the local package database if needed before installing packages
# +BEGIN_SRC emacs-lisp :tangle yes
#(defadvice package-install (before maybe-refresh-packages activate)
#  (unless (or (called-interactively-p) (assq (ad-get-arg 0) package-archive-contents))
#    (unless package--initialized
#      (package-initialize t))
#    (unless (and package-archive-contents (assq (ad-get-arg 0) package-archive-contents))
#      (package-refresh-contents))))
# +END_SRC

*** =req-package=

=req-package= is a macro wrapper on top of use-package. It's goal is to simplify
package dependencies management.

(unless (package-installed-p 'req-package)
  (package-install 'req-package))
(package-initialize)

#+BEGIN_SRC emacs-lisp :tangle yes

(defun require-package (package)
  "refresh package archives, check package presence and install if it's not installed"
  (if (null (require package nil t))
      (progn (let* ((ARCHIVES (if (null package-archive-contents)
                                  (progn (package-refresh-contents)
                                         package-archive-contents)
                                package-archive-contents))
                    (AVAIL (assoc package ARCHIVES)))
               (if AVAIL
                   (package-install package)))
             (require package))))
             
(require-package 'use-package)
(require 'use-package)
(setq use-package-always-ensure t)

(add-to-list 'load-path "~/.emacs.d/el-get/el-get")
(require-package 'el-get)
(require 'el-get)
(add-to-list 'el-get-recipe-path "~/.emacs.d/el-get/el-get/recipes")
(el-get 'sync)

(use-package use-package-el-get
  :config (use-package-el-get-setup))
  
(use-package use-package-chords)
  
(use-package req-package
  :config (req-package--log-set-level 'debug))

#+END_SRC

(require-package 'req-package)
(require 'req-package)

(setq req-package-log-level 'trace)
(req-package el-get ;; prepare el-get (optional)
  :force t ;; load package immediately, no dependency resolution
  :config
  (add-to-list 'el-get-recipe-path "~/.emacs.d/el-get/el-get/recipes")
  (el-get 'sync))

Automatically keep packages up to date.

# +BEGIN_SRC emacs-lisp :tangle yes
(req-package auto-package-update
  :ensure t
  :force true
  :config (auto-package-update-maybe))
# +END_SRC

This package also provides =bind-key=, which is really useful for managing
keybindings.

** Operating System Tweaks
*** MacOS
#+BEGIN_SRC emacs-lisp :tangle yes
(let ((path (shell-command-to-string ". ~/.zshrc; echo -n $PATH")))
  (setenv "PATH" path)
  (setq exec-path 
        (append
         (split-string-and-unquote path ":")
         exec-path)))
#+END_SRC
(req-package exec-path-from-shell
  :config 
    (progn
      (when (memq window-system '(mac ns x))
        (exec-path-from-shell-initialize)
        (exec-path-from-shell-copy-envs '("PATH")))))

** Interface
*** Theme

I prefer a smaller font, to get more text onto the screen.

#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'default nil :font "SFMono Nerd Font:pixelsize=10:weight=normal:slant=normal:width=normal:spacing=100:scalable=true")
#+END_SRC

I prefer darker themes as they're easier on my eyes, so I created one:
https://github.com/OldhamMade/leiptr-theme

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'custom-theme-load-path (expand-file-name "themes/leiptr" dotfiles-dir))
(load-theme 'leiptr t)
#+END_SRC

*** Line Numbers
Turn line-numbers on everywhere.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package hlinum
  :config
    (global-linum-mode 1)
    (setq linum-format "%4d\u2595")
    (setq column-number-mode 1)
    (hlinum-activate)
    )
#+END_SRC

Allow clicking the line-numbers to select the line(s)

#+BEGIN_SRC emacs-lisp :tangle yes
#+END_SRC
(defun line-at-click ()
  (save-excursion
  (let ((click-y (cdr (cdr (mouse-position))))
      (line-move-visual-store line-move-visual))
    (setq line-move-visual t)
    (goto-char (window-start))
    (next-line (1- click-y))
    (setq line-move-visual line-move-visual-store)
    (1+ (line-number-at-pos)))))

(defun md-select-linum ()
  (interactive)
  (goto-line (line-at-click))
  (set-mark (point))
  (setq *linum-mdown-line*
    (line-number-at-pos)))

(defun mu-select-linum ()
  (interactive)
  (when *linum-mdown-line*
  (let (mu-line)
    (setq mu-line (line-at-click))
    (goto-line (max *linum-mdown-line* mu-line))
    (set-mark (line-end-position))
    (goto-line (min *linum-mdown-line* mu-line))
    (setq *linum-mdown*
      nil))))

(bind-keys ("<left-margin> <down-mouse-1>" . md-select-linum)
           ("<left-margin> <mouse-1>" . mu-select-linum)
           ("<left-margin> <S-mouse-1>" . mu-select-linum)
           ("<left-margin> <drag-mouse-1>" . mu-select-linum))

*** Seeing changes when working with VC

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package diff-hl
  :config
    (global-diff-hl-mode 1))
#+END_SRC

*** Recursive Editing

We can make the minibuffer much more useful by enabling recursive
usage. This means that when the minibuffer is active we can still call
commands that require the minibuffer.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq enable-recursive-minibuffers t)
#+END_SRC

It's easy to lose track of whether we're in a recursive minibuffer or
not. We display the recursion level in the minibuffer to avoid confusion.

#+BEGIN_SRC emacs-lisp :tangle yes
(minibuffer-depth-indicate-mode 1)
#+END_SRC
*** Uniquify buffer names

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package uniquify
  :ensure nil
  :config
     (setq uniquify-buffer-name-style 'forward)
     )
#+END_SRC

*** Modeline
I prefer the cleaner Powerline to the usual modeline.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package powerline
  :config
  (powerline-default-theme))
#+END_SRC

Reduce the amount of rubbish in the modeline...

#+BEGIN_SRC emacs-lisp
(req-package diminish)

(add-hook 'emacs-lisp-mode-hook
  (lambda()
    (setq mode-name "el")))
#+END_SRC

*** Find convenient unbound keystrokes

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package unbound
  :load-path "custom/unbound")
#+END_SRC

** Key bindings
*** Mac
Set Option as Meta, and add Cmd as "Hyper"

#+BEGIN_SRC emacs-lisp :tangle yes
(setq mac-command-modifier 'alt
      mac-option-modifier 'meta
      mac-command-modifier 'hyper)
#+END_SRC

Undo/redo

#+BEGIN_SRC emacs-lisp :tangle yes
(bind-keys* ("H-z" . undo)
            ("H-S-z" . redo)
            ("H-Z" . redo)
            ;; Select all
            ("H-a" . mark-whole-buffer)
            ;; cut
            ("H-x" . kill-region)
            ;; copy
            ("H-c" . kill-ring-save)
            ;; paste
            ("H-v" . yank)
            ;; open
            ("H-o" . find-file)
            ;; save
            ("H-s" . save-buffer)
            ;;  close
            ("H-w" . (lambda ()
                       (interactive)
                       (my-kill-buffer
                         (current-buffer))))
            ;; quit
            ("H-q" . save-buffers-kill-emacs)
            ;; maximise
            ("<f12>" . toggle-frame-fullscreen)
            ;; minimise
            ("H-m" . iconify-frame)
            ;; hide
            ("H-h" . ns-do-hide-emacs)
            ;; search
            ;; ("H-f" . isearch-forward)
            ;; ("H-g" . isearch-repeat-forward)
            ;; jump to beginning of line
            ("H-<left>" . beginning-of-line)
            ;; jump to end of line
            ("H-<right>" . end-of-line)
            ;; jump to top of file
            ("H-t" . beginning-of-buffer)
            ;; jump to bottom of file
            ;; ("H-b" . end-of-buffer)
            ;; jump to line number
            ("H-C-l" . goto-line)
            ;; uppercase region
            ("H-u" . upcase-region)
            ;; lowercase region
            ("H-l" . downcase-region)
            ;; join a line with the previous one
            ;; and balance spaces
            ("H-S-<backspace>" . join-line)
            ;; Repeat the last command
            ("H-S-r" . repeat)
            ;; Use the Escape key to escape the keyboard
            ("<escape>" . keyboard-escape-quit)
            ;; Allow euro to be entered
            ("M-2" . (lambda ()
                       (interactive)
                       (insert "€")))
            ;; Allow hash to be entered
            ("M-3" . (lambda ()
                       (interactive)
                       (insert "#")))
            ;; make text larger
            ("H-=" . text-scale-increase)
            ;; make text smaller
            ("H--" . text-scale-decrease)
            ;; prefer ibuffer
            ("C-x C-b" . ibuffer)
            ;; tmux-style window splitting
            ("C-b -" . split-window-below)
            ("C-b |" . split-window-right)
            )
#+END_SRC

*** Key chords

I like to set up a number of key-chords that work well for my natural
hand placement on my macbook's keyboard, aiming for combos that won't
generally be activated accidentally during typing (I type quite fast).

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/key-chord-mode-hook ()
  (when (memq window-system '(mac ns))
    (key-chord-define-global "§1" 'toggle-frame-fullscreen))
  (key-chord-define-global "o0" 'find-file)
  (key-chord-define-global "o=" 'dired-jump)
  (key-chord-define-global "o-" 'ido-recentf-open)
  (key-chord-define-global "o[" 'find-file-at-point)
  (key-chord-define-global "o;" 'occur)
  (key-chord-define-global "p-" 'projectile-find-file)
  (key-chord-define-global "t5" 'untabify)
  (key-chord-define-global "r4" 'replace-string)
  (key-chord-define-global "r3" 'vr/query-replace)
  (key-chord-define-global "e3" 'er/expand-region)
  (key-chord-define-global "e2" 'er/contract-region)
  (key-chord-define-global "p[" 'fill-paragraph)
  (key-chord-define-global "p]" 'unfill-paragraph)
  (key-chord-define-global " k" 'delete-trailing-whitespace)
  (key-chord-define-global "m," 'my-previous-like-this)
  (key-chord-define-global "m." 'my-more-like-this)
  (key-chord-define-global "s1" 'ispell-region)
  (key-chord-define-global "bk" 'bm-toggle)
  (key-chord-define-global "bn" 'bm-next)
  (key-chord-define-global "bv" 'bm-previous)
  (key-chord-define-global "d3" 'dash-at-point)
  (key-chord-define-global "R$" 'ag-regexp)
  (key-chord-define-global "m;" 'multiple-cursors-hydra/body)
  (key-chord-define-global "w2" 'avy-goto-word-1)
  (key-chord-define-global "j9" 'avy-goto-word-1)
)
(req-package key-chord
  :force true
  :config
    (key-chord-mode 1)
    (my/key-chord-mode-hook))
#+END_SRC

*** Hydra
Hydra is a package that can be used to tie related commands
into a family of short bindings with a common prefix.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package hydra
  :force true)
#+END_SRC

** Auto-completion (Company mode)

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package company
  :diminish ""
  :config
    (global-company-mode 1)
    (setq company-idle-delay 0.2)
    (define-key company-active-map (kbd "M .") 'company-complete-selection)
    ; (define-key company-active-map "\t" 'company-yasnippet-or-completion)
    ; (define-key company-active-map [tab] 'company-complete-common)
)

(req-package company-quickhelp
  :requires (company)
  :config
  (progn
    ;; (bind-key "\t" 'company-complete-common company-mode-map)
    (company-quickhelp-mode 1)
    ))

 
;; With this code, yasnippet will expand the snippet if company didn't complete the word
;; replace company-complete-common with company-complete if you're using it

; (advice-add 'company-complete :before (lambda () (setq my-company-point (point))))
; (advice-add 'company-complete :after (lambda ()
;   		  				(when (equal my-company-point (point))
;   			  			  (yas-expand))))

(add-hook 'after-init-hook 'global-company-mode)

(defun company-yasnippet-or-completion ()
  (interactive)
  (if (yas/expansion-at-point)
      (progn (company-abort)
             (yas/expand))
    (company-complete-common)))

(defun yas/expansion-at-point ()
  "Tested with v0.6.1. Extracted from `yas/expand-1'"
    (first (yas/current-key)))
#+END_SRC

** Highlighting
*** Highlight syntax

Turn syntax highlighting on by default

#+BEGIN_SRC emacs-lisp :tangle yes
(global-font-lock-mode 1)
#+END_SRC

*** Highlight indentation

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package highlight-indentation
  :diminish ""
  :config
    (set-face-background 'highlight-indentation-face "#222")
    (add-hook 'prog-mode-hook 'highlight-indentation-mode)
    (add-hook 'yaml-mode-hook 'highlight-indentation-mode)
    )
#+END_SRC

*** Highlight delimiters

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package rainbow-delimiters
  :diminish ""
  :config
  (progn
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'sass-mode-hook 'rainbow-delimiters-mode)
    ))
#+END_SRC

*** Highlight variables

Rainbow identifiers subtly changes the look of variables, to make them a little
easier to visually search

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package rainbow-identifiers
  :config
  (progn
    (add-hook 'prog-mode-hook (lambda ()
                   (unless (eq major-mode 'js2-mode)
                     (rainbow-identifiers-mode))))
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package column-enforce-mode
  :diminish column-enforce-mode
  :config
  (progn
    (add-hook 'python-mode-hook 'column-enforce-mode)
    (add-hook 'alchemist-mode-hook 'column-enforce-mode)
    ))
#+END_SRC

*** Highlight colour references with it's colour

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package rainbow-mode
  :config
  (progn
    (add-hook 'clevercss-mode-hook 'rainbow-mode)
    (add-hook 'less-mode-hook 'rainbow-mode)
    (add-hook 'css-mode-hook 'rainbow-mode)
    (add-hook 'css-mode-hook 'rainbow-mode)
    (add-hook 'emacs-lisp-mode-hook 'rainbow-mode)
    ))
#+END_SRC

** Buffers
*** Initial buffer major mode: text

#+BEGIN_SRC emacs-lisp :tangle yes
(setq initial-major-mode 'text-mode)
#+END_SRC

*** New Empty Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(defun new-empty-buffer ()
  "Create a new buffer called untitled(<n>)"
  (interactive)
  (let ((newbuf (generate-new-buffer-name "untitled")))
    (switch-to-buffer newbuf)))

(bind-key* "H-n" 'new-empty-buffer)
#+END_SRC

*** Scratch buffer management

Now let's make the *scratch* buffer persistent across sessions

#+BEGIN_SRC  emacs-lisp :tangle yes
(req-package persistent-scratch
  :config
  (progn
    (persistent-scratch-setup-default)
    ))

(defun my/set-scratch-as-text ()
  (with-current-buffer (get-buffer "*scratch*")
    (let ((mode "text-mode"))
      (message "Setting scratch to text-mode")
      (funcall (intern mode)))))

(defadvice persistent-scratch-restore (after advice-persistent-scratch-restore activate)
  (my/set-scratch-as-text))

;; yas-reload-all unfortunately triggers `persistent-scratch-setup-default`
;; again, resetting the scratch to fundamental-mode, so advising here too.
;; (defadvice yas-reload-all (after advice-yas-reload-all activate)
;;  (my/set-scratch-as-text))
#+END_SRC

*** Persist certain buffers

Bury certain buffers instead of kill them

#+BEGIN_SRC emacs-lisp :tangle yes
(setq bury-buffer-names '("*scratch*" "*Messages*"))

(defun kill-buffer-query-functions-maybe-bury ()
  "Bury certain buffers instead of killing them."
  (if (member (buffer-name (current-buffer)) bury-buffer-names)
      (progn
        (kill-region (point-min) (point-max))
        (bury-buffer)
        nil)
    t))

(add-hook 'kill-buffer-query-functions 'kill-buffer-query-functions-maybe-bury)

(defun my-kill-buffer (buffer)
  "Protect some special buffers from getting killed."
  (interactive (list (current-buffer)))
  (if (member (buffer-name buffer) bury-buffer-names)
      (call-interactively 'bury-buffer buffer)
    (kill-buffer buffer)))
#+END_SRC

*** Kill all buffers except current

#+BEGIN_SRC emacs-lisp :tangle yes
(defun kill-all-buffers-except-current ()
  "Kill all buffers except current buffer."
  (interactive)
  (let ((current-buf (current-buffer)))
    (dolist (buffer (buffer-list))
      (set-buffer buffer)
      (unless (eq current-buf buffer)
        (kill-buffer buffer)))))
#+END_SRC

*** Switching buffers
**** Using cursor keys

CMD + "up"/"down" feels quite natural for me to switch
between buffers

#+BEGIN_SRC emacs-lisp :tangle yes
(defun custom-ignore-buffer (str)
  (or
   ;;buffers I don't want to switch to
   (string-match "\\*Buffer List\\*" str)
   (string-match "\\*Compile-Log\\*" str)
   (string-match "^TAGS" str)
   (string-match "^\\*Messages\\*$" str)
   (string-match "^\\*Completions\\*$" str)
   (string-match "^\\*Flymake error messages\\*$" str)
   (string-match "^\\*Flycheck error messages\\*$" str)
   (string-match "^\\*SPEEDBAR\\*" str)
   (string-match "^ " str)

   ;;Test to see if the window is visible on an existing visible frame.
   ;;Because I can always ALT-TAB to that visible frame, I never want to
   ;;Ctrl-TAB to that buffer in the current frame.  That would cause
   ;;a duplicate top-level buffer inside two frames.
   (memq str
         (mapcar
          (lambda (x)
            (buffer-name
             (window-buffer
              (frame-selected-window x))))
          (visible-frame-list)))
   ))

(defun custom-switch-buffer (ls)
  "Switch to next buffer in ls skipping unwanted ones."
  (let* ((ptr ls)
         bf bn go
         )
    (while (and ptr (null go))
      (setq bf (car ptr)  bn (buffer-name bf))
      (if (null (custom-ignore-buffer bn))        ;skip over
   (setq go bf)
        (setq ptr (cdr ptr))
        )
      )
    (if go
        (switch-to-buffer go))))

(defun custom-prev-buffer ()
  "Switch to previous buffer in current window."
  (interactive)
  (custom-switch-buffer (reverse (buffer-list))))

(bind-key "H-<down>" 'custom-prev-buffer)

(defun custom-next-buffer ()
  "Switch to the other buffer (2nd in list-buffer) in current window."
  (interactive)
  (bury-buffer (current-buffer))
  (custom-switch-buffer (buffer-list)))

(bind-key "H-<up>" 'custom-next-buffer)
#+END_SRC

**** "Other" buffers using Hydra
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/name-of-buffers (n)
  "Return the names of the first N buffers from `buffer-list'."
  (let ((bns
         (delq nil
               (mapcar
                (lambda (b)
                  (unless (string-match "^ " (setq b (buffer-name b)))
                    b))
                (buffer-list)))))
    (subseq bns 1 (min (1+ n) (length bns)))))

;; Given ("a", "b", "c"), return "1. a, 2. b, 3. c".
(defun my/number-names (list)
  "Enumerate and concatenate LIST."
  (let ((i 0))
    (mapconcat
     (lambda (x)
       (format "%d. %s" (cl-incf i) x))
     list
     "\n  ")))

(defvar my/last-buffers nil)

(defun my/switch-to-buffer (arg)
  (interactive "p")
  (switch-to-buffer
   (nth (1- arg) my/last-buffers)))

(defun my/switch-to-buffer-other-window (arg)
  (interactive "p")
  (switch-to-buffer-other-window
   (nth (1- arg) my/last-buffers)))

(defhydra hydra-switch-to-buffer 
  (:exit t
   :body-pre (setq my/last-buffers
                   (my/name-of-buffers 4)))
   "
Switch to another buffer: 
  %s(my/number-names my/last-buffers)

"
   ("o" my/switch-to-buffer "1 in this window")
   ("2" (my/switch-to-buffer 2))
   ("3" (my/switch-to-buffer 3))
   ("4" (my/switch-to-buffer 4))
   ("O" my/switch-to-buffer-other-window "1 in other window")
   ("q" nil "quit"))

(global-set-key "\C-o" 'hydra-switch-to-buffer/body)
#+END_SRC

*** Copy buffer path to kill ring

#+BEGIN_SRC emacs-lisp :tangle yes
(defun copy-full-path-to-kill-ring ()
  "copy buffer's full path to kill ring"
  (interactive)
  (when buffer-file-name
    (kill-new (file-truename buffer-file-name))))
#+END_SRC

*** Echo buffer path

#+BEGIN_SRC emacs-lisp :tangle yes
(defun describe-variable-short (var)
  (interactive "vVariable: ")
  (message (format "%s: %s" (symbol-name var) (symbol-value var))) )

(defun get-buffer-path ()
  "print the buffer path in the mini buffer"
  (interactive)
  (when buffer-file-name
    (kill-new (file-truename buffer-file-name))
    (message (format "Path: %s (copied to kill-ring)" (file-truename buffer-file-name)))
    ))
#+END_SRC

*** Display ibuffer menu commands

#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" quit-window "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                              :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                :after-exit
                                (if (eq major-mode 'ibuffer-mode)
                                    (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(add-hook 'after-init-hook
  (lambda ()
    (define-key ibuffer-mode-map "." 'hydra-ibuffer-main/body)))
#+END_SRC
** Files
*** Dired

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'dired-mode-hook 'diff-hl-dired-mode-unless-remote)
#+END_SRC

A useful Hydra to provide tips, bound to "." (same as ibuffer).

#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map "." 'hydra-dired/body)
#+END_SRC

*** Copy Filename to Clipboard

#+BEGIN_SRC emacs-lisp :tangle yes
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC

*** Open Filename with External Program

#+BEGIN_SRC emacs-lisp :tangle yes
(defun open-with ()
  "Simple function that allows us to open the underlying
file of a buffer in an external program."
  (interactive)
  (when buffer-file-name
    (shell-command (concat
                    (if (eq system-type 'darwin)
                        "open"
                      (read-shell-command "Open current file with: "))
                    " "
                    buffer-file-name))))
#+END_SRC

*** Reveal in Finder
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package reveal-in-osx-finder)
#+END_SRC
*** Rename File and Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(defun rename-file-and-buffer ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)))))))
#+END_SRC

*** Move File and Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(defun move-buffer-file (dir)
  "Move both current buffer and file it's visiting to DIR."
  (interactive "DNew directory: ")
  (let* ((name (buffer-name))
         (filename (buffer-file-name))
         (dir
          (if (string-match dir "\\(?:/\\|\\\\)$")
              (substring dir 0 -1) dir))
         (newname (concat dir "/" name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (copy-file filename newname 1)
      (delete-file filename)
      (set-visited-file-name newname)
      (set-buffer-modified-p nil)
      t)))
#+END_SRC

*** Reloading
Always reload the file on disk when it updates

#+BEGIN_SRC emacs-lisp :tangle yes
(global-auto-revert-mode 1)
#+END_SRC

*** Autosaves and Backups

Enable auto-save of files as they are edited, so that no changes are lost.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package super-save
  :diminish ""
  :config
    (progn
      (super-save-mode +1)
      (setq super-save-auto-save-when-idle t)  ;; autosave to the real file
      (setq auto-save-default nil)  ;; disable autosave to backup file
      ))
#+END_SRC

Autosaving of files

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-save-file-name-transforms `((".*" ,"~/.emacs.d/auto-backup/" t)))
#+END_SRC

Backup files to a local directory.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
    '(("." . "~/.emacs.d/auto-backup/"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+END_SRC

Disable annoying lockfiles

#+BEGIN_SRC emacs-lisp :tangle yes
(setq create-lockfiles nil)
#+END_SRC

*** Saving

Always append a new line to the file

#+BEGIN_SRC emacs-lisp :tangle yes
(setq require-final-newline t)
#+END_SRC

Clean whitespace intelligently on save

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package whitespace-cleanup-mode
  :diminish whitespace-cleanup-mode
  :config (progn (global-whitespace-cleanup-mode)))
#+END_SRC

** Navigation
*** Minibuffer Shortcuts
When selecting a file to visit, // will mean /
and ~ will mean $HOME regardless of preceding text

#+BEGIN_SRC emacs-lisp :tangle yes
(setq file-name-shadow-tty-properties '(invisible t))
(file-name-shadow-mode 1)
#+END_SRC

*** Open recently opened files quickly

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package recentf
  :config
  (progn
    (recentf-mode 1)
    (setq recentf-max-save-items 500
          recentf-max-menu-items 100)
    (add-to-list 'recentf-exclude "ido\\.last\\'")
    (recentf-cleanup)
  ))
#+END_SRC

*** IDO

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package ido-completing-read+
  :force true
  :require (ido recentf memoize)
  :config
  (progn
    (ido-mode t)
    (setq ido-confirm-unique-completion nil)
    (setq ido-create-new-buffer 'always)
    (setq ido-enable-flex-matching t)
    (setq ido-ignore-extensions t)
    (setq ido-use-virtual-buffers t)
    (ido-ubiquitous-mode 1)
    ))
#+END_SRC

Flx is rather useful, so let's add that too

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package flx-ido
  :require flx
  :config
  (progn
    (flx-ido-mode 1)
    ))
#+END_SRC

Use ido for recently open files

#+BEGIN_SRC emacs-lisp :tangle yes
(defun ido-recentf-open ()
  "Use `ido-completing-read' to \\[find-file] a recent file"
  (interactive)
  (if (find-file (ido-completing-read "Find recent file: " recentf-list))
      (message "Opening file...")
    (message "Aborting")))

(bind-key "H-S-o" 'ido-recentf-open)
#+END_SRC

*** Smex

Improve M-x with recent/popular commands at prompt.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package smex
  :bind (("M-x" . smex)
         ("M-X" . smex-major-mode-commands)
         ("C-c C-c M-x" . execute-extended-command)))
#+END_SRC

*** Projectile

Automagically interact with "projects"; git, mercurial, bazaar, and darcs repos
are seen as projects by default.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package projectile
  :diminish ""
  :config
    (projectile-global-mode)
    )
#+END_SRC

** Moving Around
*** By indentation

`C-a' normally moves us to the beginning of the line
unconditionally. This version is more useful, as it moves to the
first non-whitespace character if we're already at the beginning of
the line. Repeated use of `C-a' toggles between these two positions.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun beginning-of-line-dwim ()
    "Toggles between moving point to the first non-whitespace character, and
  the start of the line."
    (interactive)
    (let ((start-position (point)))
      (move-beginning-of-line nil)
      (when (= (point) start-position)
          (back-to-indentation))))

  (bind-keys
    ("C-a" . beginning-of-line-dwim)
    ("H-<left>" . beginning-of-line-dwim))
#+END_SRC

*** By last change

It can be rather handy to jump to the last changed area in a file.

KEYBINDING: "H-r"

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package goto-last-change
             :diminish ""
             :bind ("H-r" . goto-last-change))
#+END_SRC

*** Avy
Avy is a package for jumping to visible text using a char-based decision tree

KEYBINDING: "M-j"

#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-avy (:color blue)
  "avy-goto"
  ("j" avy-goto-char "char")
  ("k" avy-goto-char-2 "char-2")
  ("l" avy-goto-line "line")
  ("q" nil "quit"))

(req-package avy
  :require (hydra)
  :diminish ""
  :config
    (global-set-key (kbd "M-j") 'avy-goto-char-2)
    (global-set-key (kbd "M-s") 'avy-goto-word-1))
#+END_SRC

*** Bookmarks
#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-bookmarks (:color pink :hint nil)
  "
 ^Bookmarks^
-^---------^----------------------------------------------
  [_t_] toggle bookmark
  [_n_] jump to next      [_s_] show (from current buffer)
  [_p_] jump to previous  [_a_] show (from all buffers)
-^---------^----------------------------------------------
"
  ("t" bm-toggle "toggle")
  ("n" bm-next "next")
  ("p" bm-previous "previous")
  ("s" bm-show "show (current buffer)")
  ("a" bm-show-all "show (all buffers)")
  ("q" nil)
)
(req-package bm
  :require (hydra)
  :diminish ""
  :config
    (global-set-key (kbd "H-b") 'hydra-bookmarks/body)
)
#+END_SRC
*** Jump around
#+begin_src emacs-lisp :tangle yes
(defun occur-dwim ()
  "Call `occur' with a sane default, chosen as the thing under point or selected region"
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (let ((sym (thing-at-point 'symbol)))
            (when (stringp sym)
              (regexp-quote sym))))
        regexp-history)
  (call-interactively 'occur))

(defun noccur-project-dwim ()
  "Call `occur' with a sane default, chosen as the thing under point or selected region"
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (let ((sym (thing-at-point 'symbol)))
            (when (stringp sym)
              (regexp-quote sym))))
        regexp-history)
  (call-interactively 'noccur-project))

(defadvice occur-mode-goto-occurrence (after occur-mode-goto-occurrence-advice activate)
  (other-window 1)
  (kill-buffer)
  (delete-window))

;; Focus on *Occur* window right away.
(add-hook 'occur-hook (lambda () (other-window 1)))

(defhydra hydra-jump (:color pink :hint nil)
  "
 ^Dumb Jump^                       | ^Symbol Jump^           | ^Avy Jump^    | ^Buffer Jump^  
-^---------^-----------------------+-^-----------^-----------+-^--------^----+-^-----------^----
  [_j_] jump to symbol             |  [_s_] symbol at point  |  [_c_] char   |  [_t_] top     
  [_r_] jump back (return)         |  [_n_] next             |  [_2_] char2  |  [_b_] bottom  
  [_w_] jump, target other window  |  [_p_] previous         |  [_l_] line   |
  [_x_] jump, preferring external  |  [_o_] occurances       | ^^            |  [_g_] goto line
  [_ _] quick look                 |  [_m_] all occurances   | ^^            |
-^---------^-----------------------+-^-----------^-----------+-^---------^---+-^-----------^----
"
  ("j" dumb-jump-go)
  ("r" dumb-jump-back)
  (" " dumb-jump-quick-look)
  ("w" dumb-jump-go-other-window)
  ("x" dumb-jump-go-prefer-external)
  ("t" beginning-of-buffer :exit t)
  ("b" end-of-buffer :exit t)
  ("s" isearch-forward-symbol-at-point)
  ("n" isearch-repeat-forward :color red)
  ("p" isearch-repeat-backward :color red)
  ("o" occur-dwim :exit t)
  ("m" noccur-project-dwim :exit t)
  ("g" goto-line :exit t)
  ("c" avy-goto-word-1 :exit t)
  ("2" avy-goto-char-2 :exit t)
  ("l" avy-goto-line :exit t)
  ("q" (lambda () (interactive) (isearch-done)) :exit t)
)
(req-package dumb-jump
  :require (noccur)
  :diminish ""
  :defer t
  :bind ("H-j" . hydra-jump/body)
  :config
  (progn
    (setq dumb-jump-force-searcher 'ag)
    (setq dumb-jump-default-project "~/Projects")))
#+END_SRC

** Editing
*** Showing changes
Highlight changes to the buffer caused by commands such as ‘undo’, ‘yank’/’yank-pop’, etc.

Note: disabled for now, as it interacts badly with cua-paste

#+BEGIN_SRC emacs-lisp :tangle no
(req-package volatile-highlights
             :defer t
             :diminish volatile-highlights-mode
             :config (volatile-highlights-mode t))
#+END_SRC

*** Tabs

Since I generally develop with languages that adhere to the "off-side" rule
(eg, Python) always replace tabs with spaces.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default indent-tabs-mode nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(electric-indent-mode +1)
#+END_SRC

Set tab width to 4 for all buffers

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default tab-width 4)
#+END_SRC

Add smart tabs

# +BEGIN_SRC emacs-lisp :tangle yes
(req-package smart-tabs-mode
  :defer t
  :diminish t
  :config
    (smart-tabs-insinuate 'c 'javascript 'python 'ruby 'nxml)
  )
# +END_SRC

*** Overwriting

When there's an active selection, delete on inserting new text (overwrite)

#+BEGIN_SRC emacs-lisp :tangle yes
(delete-selection-mode +1)
#+END_SRC

*** Undo
Standard Emacs undo is kind of confusing. [[http://www.dr-qubit.org/emacs.php#undo-tree][undo-tree]] replaces this with a
simpler tree structure. It also allows us to visualize the tree directly.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package undo-tree
             :ensure undo-tree
             :diminish ""
             :config (global-undo-tree-mode))
#+END_SRC

*** CUA

Enable CUA mode for using =C-RET= for working with rectangles.

#+BEGIN_SRC emacs-lisp :tangle yes
(cua-mode)
(setq cua-enable-cua-keys nil
      cua-remap-control-v nil
      cua-highlight-region-shift-only t
      cua-toggle-set-mark nil)

(setq-default cua-enable-cua-keys nil
              cua-highlight-region-shift-only t
              cua-toggle-set-mark nil)

;; re-bind H-v to yank, as cua-paste breaks other modes
(global-unset-key (kbd "H-v"))
(define-key cua-global-keymap (kbd "H-v") nil)
(define-key cua-global-keymap [remap cua-paste] 'yank)
(bind-keys* ("H-v" . yank))

;; shift + click select region
(define-key global-map (kbd "<S-down-mouse-1>") 'ignore) ; turn off font dialog
(define-key global-map (kbd "<S-mouse-1>") 'mouse-set-point)
(put 'mouse-set-point 'CUA 'move)
#+END_SRC

Transient-mark-mode needs to be reenabled after enabling CUA-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(setq transient-mark-mode t)
#+END_SRC

*** Auto-pair braces

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package autopair
             :diminish autopair-mode
             :config
             (progn
              (autopair-global-mode)
              (setq show-paren-delay 0
                    show-paren-style 'parenthesis)
              (show-paren-mode t)
              (add-hook 'term-mode-hook
                        #'(lambda ()
                            (setq autopair-dont-activate t)
                            (autopair-mode -1)))
              ))
#+END_SRC

*** Sort lines, case insensitive

#+BEGIN_SRC emacs-lisp :tangle yes
(defun sort-lines-nocase ()
  (interactive)
  (let ((sort-fold-case t))
    (call-interactively 'sort-lines)))
#+END_SRC

*** Fix/replace "Smart Quotes"

#+BEGIN_SRC emacs-lisp :tangle yes
(defun fix-smart-quotes (beg end)
  "Replace 'smart quotes' in buffer or region with ascii quotes."
  (interactive "r")
  (format-replace-strings '(("\x201C" . "\"")
                            ("\x201D" . "\"")
                            ("\x2018" . "'")
                            ("\x2019" . "'"))
                          nil beg end))
#+END_SRC

*** Remove ^M

#+BEGIN_SRC emacs-lisp :tangle yes
(defun remove-control-m ()
  (interactive)
  (goto-char 1)
  (while (search-forward "
" nil t)
    (replace-match "" t nil)))
#+END_SRC

*** Unfill paragraph

Unfill functions providing the inverse of fill-paragraph and fill-region

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package unfill)
#+END_SRC

*** Browse Kill Ring

KEYBINDING: "M-y"

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package browse-kill-ring
             :config (browse-kill-ring-default-keybindings))
#+END_SRC

*** Remote editing via tramp

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package tramp
             :config (setq tramp-default-method "ssh"))
#+END_SRC

*** Expand region
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package expand-region)
#+END_SRC

*** Multiple Cursors
#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra multiple-cursors-hydra (:hint nil)
  "
     ^Up^            ^Down^        ^Other^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
^ ^             ^ ^             [_q_] Quit
"
  ("l" mc/edit-lines)
  ("a" mc/mark-all-like-this)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("r" mc/mark-all-in-region-regexp)
  ("q" nil)
  ("<mouse-1>" mc/add-cursor-on-click)
  ("<down-mouse-1>" ignore)
  ("<drag-mouse-1>" ignore)
)

(req-package multiple-cursors
  :config (define-key mc/keymap (kbd "<return>") nil))
#+END_SRC

*** Transpose
#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-transpose (:color red)
  "Transpose"
   ("c" transpose-chars "characters")
   ("w" transpose-words "words")
   ("o" org-transpose-words "Org mode words")
   ("l" transpose-lines "lines")
   ("s" transpose-sentences "sentences")
   ("e" org-transpose-elements "Org mode elements")
   ("p" transpose-paragraphs "paragraphs")
   ("t" org-table-transpose-table-at-point "Org mode table")
   ("q" nil "cancel" :color blue))
(global-set-key (kbd "M-t") 'hydra-transpose/body)
#+END_SRC

*** Move text
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package move-text
  :diminish ""
  :defer t
  :config (move-text-default-bindings))
#+END_SRC

*** Duplicate lines/region
(defun duplicate-line (arg)
  "Duplicate current line, leaving point in lower line."
  (interactive "*p")

  ;; save the point for undo
  (setq buffer-undo-list (cons (point) buffer-undo-list))

  ;; local variables for start and end of line
  (let ((bol (save-excursion (beginning-of-line) (point)))
        eol)
    (save-excursion

      ;; don't use forward-line for this, because you would have
      ;; to check whether you are at the end of the buffer
      (end-of-line)
      (setq eol (point))

      ;; store the line and disable the recording of undo information
      (let ((line (buffer-substring bol eol))
            (buffer-undo-list t)
            (count arg))
        ;; insert the line arg times
        (while (> count 0)
          (newline)         ;; because there is no newline in 'line'
          (insert line)
          (setq count (1- count)))
        )

      ;; create the undo information
      (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list)))
    ) ; end-of-let

  ;; put the point in the lowest line and return
  (next-line arg))

(global-set-key (kbd "C-d") 'duplicate-line)
#+BEGIN_SRC emacs-lisp :tangle yes
(defun duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (let (beg end (origin (point)))
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (let ((region (buffer-substring-no-properties beg end)))
      (dotimes (i arg)
        (goto-char end)
        (newline)
        (insert region)
        (setq end (point)))
      (goto-char (+ origin (* (length region) arg) arg)))))
(global-set-key (kbd "C-d") 'duplicate-current-line-or-region)
#+END_SRC
*** Folding
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path (expand-file-name "custom/fold-dwim" dotfiles-dir))
(require 'fold-dwim)

(req-package fold-dwim
  :bind ("M-RET" . hydra-fold/body)
  :init 
    (defhydra hydra-fold (:pre (hs-minor-mode 1) :color blue)
      "fold"
      ("RET" fold-dwim-toggle "toggle")
      ("a" fold-dwim-hide-all "hide-all")
      ("s" fold-dwim-show-all "show-all")
      ("q" nil "quit")))
#+END_SRC
(global-set-key (kbd "M-RET") 'hydra-fold/body)

** Search/replace
*** The Silver Searcher

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package ag)
#+END_SRC

*** Showing search results
Display 'current match/total matches' in the mode-line in various search modes

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package anzu
  :diminish anzu-mode
  :config (global-anzu-mode +1))
#+END_SRC

*** Regex search/replace
I'm not a big fan of the regular expression syntax in emacs,
so install visual-regexp-steroids to use Python's regex model.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package visual-regexp-steroids
             :require (visual-regexp)
             :bind (("C-c r" . vr/replace)
                    ("C-c q" . vr/query-replace)
                    ("C-r" . vr/isearch-backward)
                    ("C-s" . vr/isearch-forward)))
#+END_SRC

*** Occur
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package occur-x
  :config 
    (progn
      (setq occur-linenumbers-in-margin 1)
      (add-hook 'occur-mode-hook 'turn-on-occur-x-mode)
      ))
#+END_SRC

** Windows
*** Recover window split with winner-mode
Enable C-c <left> to get back the previous window split

#+BEGIN_SRC emacs-lisp :tangle yes
(winner-mode 1)
#+END_SRC

*** Jumping between windows

Allow switching between windows with CTRL+Tab

#+BEGIN_SRC emacs-lisp :tangle yes
(bind-key "C-<tab>" 'other-window)
#+END_SRC

*** Mimic tmux

I use tmux a lot, and often find when I switch back to emacs
that I use the tmux pane-switch command from muscle memory.

#+BEGIN_SRC emacs-lisp :tangle yes
(unbind-key "\C-b")
(bind-keys* ("C-b <down>" . other-window)
            ("C-b <up>" . previous-multiframe-window))
#+END_SRC

** Org-mode
*** Fix keybindings
Allow indenting natively within source blocks.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-src-tab-acts-natively t)
#+END_SRC

Org-mode has some keybindings which I find very annoying as they interfere 
with my preferred keybindings, so I'll remove them here.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'org-mode-hook
  (lambda()
    (local-unset-key (kbd "C-<tab>")) ; allow switching between frames
    (local-unset-key (kbd "M-S-<left>")) ; allow selecting while word-jumping
    (local-unset-key (kbd "M-S-<right>")) ; allow selecting while word-jumping
    (local-set-key (kbd "M-H-<left>") 'org-shiftmetaleft) ; allow selecting while word-jumping
    (local-set-key (kbd "M-H-<right>") 'org-shiftmetaright) ; allow selecting while word-jumping
    ))
#+END_SRC

I like to shift-select things, so enable that.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-support-shift-select 'always)
#+END_SRC

**** Bullets
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package org-bullets
             :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

**** Todo

Add font styles to DONE lines.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-fontify-done-headline t)
#+END_SRC

** Programming
*** Common
**** Git interaction
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package magit
  :config
    (setq magit-branch-arguments nil)
    (setq magit-push-arguments '("--set-upstream"))
    )

(req-package magithub
  :after magit
  :config
    (magithub-feature-autoinject t)
    (setq magithub-clone-default-directory "~/Projects")
    )
#+END_SRC
**** Enable CamelCase awareness for all programming modes
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'subword-mode)
(eval-after-load "subword" '(diminish 'subword-mode))
#+END_SRC
**** Better commenting
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package comment-dwim-2
             :bind  (("M-;" . comment-dwim-2)))
#+END_SRC

*** Dash
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package dash-at-point)
#+END_SRC

*** Flycheck

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package flycheck
  :require (dash s f exec-path-from-shell flycheck-color-mode-line)
  :ensure flycheck
  :config (add-hook 'after-init-hook 'global-flycheck-mode)
  :defer t
  :config
  (progn
    (add-hook 'after-init-hook 'global-flycheck-mode)
    (eval-after-load "flycheck"
      '(add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
    ))
#+END_SRC
  :diminish " ✓ "

*** General
**** Python

A hydra for testing with nose.

#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-nosetest (:color blue)
  "nosetest"
  ("t" nosetests-all "test all")
  ("m" nosetests-module "module")
  ("o" nosetests-one "one")
  ("a" nosetests-again "again")
  ("q" nil "cancel"))
#+END_SRC

Install elpy for working with Python, with the =jedi= backend, and nose.

#+BEGIN_SRC emacs-lisp :tangle yes
#+END_SRC
(req-package elpy
  :commands elpy-mode
  :defer t
  :config
  (progn
    (setq elpy-rpc-backend "jedi")
    (elpy-enable)
   ))

               # ; (setq python-fill-docstring-style 'symmetric)
#                ;(when (executable-find "ipython")
#                ;  (elpy-use-ipython))
#                ;(nose-mode t)
#                ;           ("C-c n" . hydra-nosetest/body))

# TODO: add `python-docstring-mode` to requirements for elpy
#              :require (nose)

# Enable company mode auto-completion backend for python, and some
# custom key-bindings

(defun python-backtab ()
  (interactive)
  (if mark-active
      (let (deactivate-mark)
        (python-indent-shift-left (region-beginning) (region-end)))))

(defun python-tab ()
  (interactive)
  (if mark-active
      (let (deactivate-mark)
        (python-indent-shift-right (region-beginning) (region-end)))
    (indent-for-tab-command)))

(defun python-backtab ()
  (interactive)
  (if mark-active
      (let (deactivate-mark)
        (python-indent-shift-left (region-beginning) (region-end)))))

(defun python-tab ()
  (interactive "^")
  (python-indent-shift-right 1)
  (back-to-indentation))

(defadvice python-indent-shift-right (after python-indent-shift-right activate)
  (back-to-indentation))

  # (elpy-mode)
  # (bind-keys :map elpy-mode-map
  #            ("M-<left>" . nil)
  #            ("M-<right>" . nil))

#+BEGIN_SRC emacs-lisp :tangle yes
(defun pyfile-overview ()
  (interactive)
  (occur "class \\\|def "))

(defun my/python-mode-hook ()
  (add-to-list 'company-backends 'company-jedi)
  (smart-tabs-advice python-indent-line-1 python-indent)
  )
(add-hook 'python-mode-hook 'my/python-mode-hook)
#+END_SRC

  (elpy-enable)
  (with-eval-after-load 'company-mode
    (add-to-list 'company-backends 'company-jedi)
    (company-mode)))

  # ;(with-eval-after-load 'company-mode
  #   ;(bind-keys :map elpy-mode-map
  #   ;           ("<tab>" . python-indent-shift-right)
  #   ;           ("S-<tab>" . python-indent-shift-left))
  #   ;(add-to-list 'company-backends 'company-jedi)
  #   ;(company-mode)
  #   ;(python-docstring-mode)
  #   ;
  #   ;))

  # (bind-keys :map python-mode-map
  #            ("M-<left>" . nil)
  #            ("M-<right>" . nil)
  #            ("C-M-<left>" . elpy-nav-indent-shift-left)
  #            ("C-M-<right>" . elpy-nav-indent-shift-right)
  #            ("<tab>" . elpy-nav-indent-shift-right)
  #            ("<backtab>" . elpy-nav-indent-shift-left)))

  # (setq electric-indent-chars (delq ?: electric-indent-chars))

I occasionally use Jinja for templating, so let's add that mode too.

#+BEGIN_SRC emacs-lisp :tangle yes
#+END_SRC
(req-package jinja2-mode
             :diminish ""
             :mode ("\\.jinja2?\\'" . jinja2-mode))
(add-to-list 'auto-mode-alist '("\\.j2\\'" . jinja2-mode))
(setq web-mode-engines-alist
             '("jinja" . "\\.j2\\"))

Add =cython-mode= for working with Cython files.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package cython-mode)
#+END_SRC

**** Elixir
Adding Alchemist for elixir programming.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package alchemist
  :requires (elixir-mode ruby-end)
  :defer t
  :mode ("\\.exs?\\'" . alchemist-mode))

(add-hook 'elixir-mode-hook 'alchemist-mode)
(add-hook 'elixir-mode-hook 'company-mode)
(add-hook 'elixir-mode-hook
          (lambda ()
            (setq alchemist-mix-command "source /usr/local/Cellar/asdf/0.4.3/asdf.sh && mix"
                  alchemist-execute-command "source /usr/local/Cellar/asdf/0.4.3/asdf.sh && elixir"
                  alchemist-iex-program-name "source /usr/local/Cellar/asdf/0.4.3/asdf.sh && iex"
                  alchemist-compile-command "source /usr/local/Cellar/asdf/0.4.3/asdf.sh && elixirc")
            (set (make-variable-buffer-local 'ruby-end-expand-keywords-before-re)
                 "\\(?:^\\|\\s-+\\)\\(?:do\\)")
            (set (make-variable-buffer-local 'ruby-end-check-statement-modifiers)
                 nil)
            (ruby-end-mode 1)
            ))

(req-package delight)
(delight '((emacs-lisp-mode "elisp" :major)
           (elixir-mode "[ex]" elixir)
           (alchemist-mode "[al]" alchemist)
           (alchemist-hex-mode "[alhex]" alchemist)
           (alchemist-test-mode "[altest]" alchemist)
           (ruby-end-mode "" ruby-end)))
#+END_SRC
(push (expand-file-name "/usr/local/Cellar/asdf/0.4.3/installs/elixir/1.6.5/bin") exec-path)
(push (expand-file-name "/usr/local/Cellar/asdf/0.4.3/installs/erlang/20.3.6/bin") exec-path)

            (setq alchemist-mix-command "/usr/local/Cellar/asdf/0.4.3/installs/elixir/1.6.5/bin/mix"
                  alchemist-execute-command "/usr/local/Cellar/asdf/0.4.3/installs/elixir/1.6.5/bin/elixir"
                  alchemist-iex-program-name "/usr/local/Cellar/asdf/0.4.3/installs/elixir/1.6.5/bin/iex"
                  alchemist-compile-command "/usr/local/Cellar/asdf/0.4.3/installs/elixir/1.6.5/bin/elixirc")
            (setq alchemist-mix-command "/usr/local/Cellar/asdf/0.4.3/shims/mix"
                  alchemist-execute-command "/usr/local/Cellar/asdf/0.4.3/shims/elixir"
                  alchemist-iex-program-name "/usr/local/Cellar/asdf/0.4.3/shims/iex"
                  alchemist-compile-command "/usr/local/Cellar/asdf/0.4.3/shims/elixirc")

Support for .eex files

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.eex\\'" . web-mode))
#+END_SRC

Code folding

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'hs-special-modes-alist
             '(elixir-mode
               ("\\(cond\\|quote\\|defmacro\\|defmacrop\\|defp\\|def\\|if\\) .*\\(do\\)" 2) "\\(end\\)" "#"
               nil nil))
#+END_SRC

(eval-after-load "hideshow"
  '(add-to-list 'hs-special-modes-alist
                `(elixir-mode
                  ,(rx "do")  ; Block start
                  ,(rx "end") ; Block end
                  ,(rx "#")  ; Comment start
                  nil
                  nil)))
**** Erlang

##+BEGIN_SRC emacs-lisp :tangle yes
#(req-package erlang-mode
#             :requires (company-erlang)
#             :defer t
#             :mode ("\\.erl\\'" . erlang-mode))
##+END_SRC

**** Nim
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package nim-mode
  :defer t
  :mode ("\\.nim\\'" . nim-mode))
#+END_SRC
  :config
  (progn
    (add-to-list 'company-backends
      '(company-nim :with company-nim-builtin))
    ))
*** Web
**** HTML et al
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package web-mode
             :defer t)

(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
;(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.ecr\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

;; use eslint with web-mode for jsx files
(with-eval-after-load 'flycheck
  (flycheck-add-mode 'javascript-eslint 'web-mode))

;; adjust indents for web-mode to 2 spaces
(defun my-web-mode-hook ()
  "Hooks for Web mode. Adjust indents"
  ;;; http://web-mode.org/
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))

(add-hook 'web-mode-hook  'my-web-mode-hook)
#+END_SRC

**** JavaScript
Adding JavaScript
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package js2-mode
             :config
             (progn
               (setq-default js-indent-level 2)
               (setq-default js2-basic-offset 2)

               (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
               ;; Better imenu
               (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
               ))
#+END_SRC

(req-package js2-mode
             :require (ac-js2 json-mode)
             :config
             (progn
               ;; disable jshint since we prefer eslint checking
               (setq-default flycheck-disabled-checkers
                 (append flycheck-disabled-checkers
                   '(javascript-jshint)))

               ;; disable json-jsonlist checking for json files
               (setq-default flycheck-disabled-checkers
                 (append flycheck-disabled-checkers
                   '(json-jsonlist)))

               (setq-default js-indent-level 2)
               (setq-default js2-basic-offset 2)
               (add-hook 'js-mode-hook 'js2-minor-mode)
               (add-hook 'js2-mode-hook 'ac-js2-mode)
               (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
               (add-to-list 'auto-mode-alist '("\\.jsx?\\'" . js2-jsx-mode))

               ;; Better imenu
               (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)

               ;; for better jsx syntax-highlighting in web-mode
               ;; - courtesy of Patrick @halbtuerke
               (defadvice web-mode-highlight-part (around tweak-jsx activate)
                 (if (equal web-mode-content-type "jsx")
                   (let ((web-mode-enable-part-face nil))
                     ad-do-it)
                   ad-do-it))

               ))

**** Elm

I often use Elm for front-end development.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package elm-mode
             :requires (flycheck-elm))
;(eval-after-load 'flycheck
;    '(add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
(with-eval-after-load 'company
  (add-to-list 'company-backends 'company-elm))
(add-hook 'elm-mode-hook 'company-mode)
(add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
#+END_SRC

**** WebMode

#+BEGIN_SRC emacs-lisp :tangle yes
(setq web-mode-engines-alist
	  '(
		("elixir"	 . "\\.eex\\'")
		)
	  )
#+END_SRC

**** Utilities
***** YASnippet
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package yasnippet
             :config (yas-global-mode 1))
(add-hook 'sass-mode-hook
   '(lambda () (set (make-local-variable 'yas-indent-line) 'fixed)))
#+END_SRC

** Markup
*** Sass/Scss
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package sass-mode
             :requires (flycheck-sass))
#+END_SRC
*** Yaml
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package yaml-mode
             :requires (flycheck-yaml))
(add-to-list 'auto-mode-alist '("\\.raml\\'" . yaml-mode))
#+END_SRC
*** Markdown
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package markdown-mode
             :requires (flycheck-markdown))
#+END_SRC
*** Docker
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package dockerfile-mode)
#+END_SRC
** Terminal
*** Multi-term

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package multi-term
             :config
             (progn
               (setq multi-term-program "/bin/zsh")
               ))
#+END_SRC

*** Misc fixes

#+BEGIN_SRC emacs-lisp :tangle yes
(setq term-scroll-show-maximum-output 1)
(setq system-uses-terminfo nil)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
(add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
#+END_SRC
** Finalising
*** Kick-off the package install.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package esup)
(req-package-finish)
#+END_SRC

*** Set default gc

Now everything is set up, I want to return the gc level
back to the default to make the UI more responsive

#+BEGIN_SRC emacs-lisp :tangle yes
(setq gc-cons-threshold (* 2 1000 1000))
#+END_SRC

I also want to make sure any minibuffer operations
don't trigger the gc, so tools like flx won't pause.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold 800000))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
#+END_SRC

Now that we're done, let's see just how long it took to start up.

(lambda () (interactive) (emacs-init-time))
#+BEGIN_SRC emacs-lisp :tangle yes
#+END_SRC
