#+TITLE: Emacs Configuration
#+AUTHOR: Phillip B Oldham

* Introduction

  This file is a literate programming document written with org-mode
  and org-mode-babel which contains the configuration I use for
  development.
* Contents
** =early-init.el=
   The following configuration have been moved to =early-init.el= for
   performance reasons, and are therefore not tangled here.
*** Use lexical binding
    This buys a small improvement in performance, but every little bit
    helps.
    #+BEGIN_SRC emacs-lisp :tangle no
    ;; -*- lexical-binding: t; -*-
    #+END_SRC
*** Increase startup threshold
    Emacs will run garbage collection after `gc-cons-threshold' bytes of
    consing. The default value is 800,000 bytes, or ~ 0.7 MiB. By
    increasing to maximum we reduce the number of pauses due to
    garbage collection during setup.

    #+BEGIN_SRC emacs-lisp :tangle no
    (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
          gc-cons-percentage 0.6)
    #+END_SRC
*** Hide the toolbar
    #+BEGIN_SRC emacs-lisp :tangle no
    (ignore-errors
      (tool-bar-mode -1))
    #+END_SRC
*** Hide scrollbars
    #+BEGIN_SRC emacs-lisp :tangle no
    (ignore-errors
      (scroll-bar-mode -1))
    #+END_SRC
*** Disable the cursor blink
    #+BEGIN_SRC emacs-lisp :tangle no
    (blink-cursor-mode -1)
    #+END_SRC
*** Disable alarm bells
    #+BEGIN_SRC emacs-lisp :tangle no
    (setq visible-bell nil)
    (setq ring-bell-function 'ignore)
    #+END_SRC
*** Disable instructions in the scratch buffer
    #+BEGIN_SRC emacs-lisp :tangle no
    (setq initial-scratch-message nil)
    #+END_SRC
*** Reduce the message log to the last 512 entries
    #+BEGIN_SRC emacs-lisp :tangle no
    (setq message-log-max 512)
    #+END_SRC
*** Enable debug mode when errors occur
    #+BEGIN_SRC emacs-lisp :tangle no
    (setq debug-on-error t)
    #+END_SRC
*** Disable window resizing on font change
    Emacs resizes the (GUI) frame when your newly set font is larger
    (or smaller) than the system default. This seems to add 0.4-1s
    to startup.
    #+BEGIN_SRC emacs-lisp :tangle no
    (setq frame-inhibit-implied-resize t)
    #+END_SRC
** Startup
*** Better GC handling
**** Define a sane value for general use
     #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar my--gc-cons-threshold 16777216)
     #+END_SRC
**** Set sane value after startup
     At the end of setup this value should be returned to the default, once
     startup has completed.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'emacs-startup-hook
       (lambda ()
       (setq gc-cons-threshold my--gc-cons-threshold
             gc-cons-percentage 0.1)))
     #+END_SRC
**** Handle the minibuffer differently
     I want to make sure any minibuffer operations
     won't trigger gc, so tools like =flx= won't pause.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/minibuffer-setup-hook ()
       (setq gc-cons-threshold most-positive-fixnum))

     (defun my/minibuffer-exit-hook ()
       ;; Defer it so that commands launched immediately after will enjoy the
       ;; benefits.
       (run-at-time
         1 nil (lambda () (setq gc-cons-threshold my--gc-cons-threshold))))

     (add-hook 'minibuffer-setup-hook #'my/minibuffer-setup-hook)
     (add-hook 'minibuffer-exit-hook #'my/minibuffer-exit-hook)
     #+END_SRC
**** Do a GC when emacs loses focus
     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun dotfiles--gc-on-last-frame-out-of-focus ()
       "GC if all frames are inactive."
       (if (seq-every-p #'null (mapcar #'frame-focus-state (frame-list)))
         (garbage-collect)))

     (add-function :after after-focus-change-function
       #'dotfiles--gc-on-last-frame-out-of-focus)
     #+END_SRC
*** Unset file-name-handler-alist temporarily
    Emacs consults this variable every time a file is read or library
    loaded, or when certain functions in the file API are used (like
    expand-file-name or file-truename).

    It does so to check if a special handler is needed to read the
    file, but none of these handlers are necessary for startup, so it
    is generally safe to disable it temporarily:

    #+BEGIN_SRC emacs-lisp :tangle yes
    ;; copy to custom var
    (defvar my--file-name-handler-alist file-name-handler-alist)
    ;; set original to nil
    (setq file-name-handler-alist nil)
    ;; Restore after startup
    (add-hook 'emacs-startup-hook
      (lambda ()
        (setq file-name-handler-alist my--file-name-handler-alist)))
    #+END_SRC
*** Check for native JSON support
    #+BEGIN_SRC emacs-lisp :tangle yes
    (if (functionp 'json-serialize)
      (message "Native JSON is available")
      (message "Native JSON is *not* available"))
    #+END_SRC
*** Set native compilation if available
    #+BEGIN_SRC emacs-lisp :tangle yes
    (if (and (fboundp 'native-comp-available-p)
       (native-comp-available-p))
       (setq comp-deferred-compilation t)
       (message "Native complation is *not* available"))
    #+END_SRC
*** Add timestamps to messages
    Adding timestamps to the messages so we can see whether anything
    is causing emacs to block for a significant amount of time.

    #+BEGIN_SRC emacs-lisp :tangle yes
    ;;; timestamps in *Messages*
    (defun current-time-microseconds ()
      (let* ((nowtime (current-time))
             (now-ms (nth 2 nowtime)))
        (concat (format-time-string "[%Y-%m-%dT%T" nowtime) (format ".%d] " now-ms))))

    (defadvice message (before test-symbol activate)
      (if (not (string-equal (ad-get-arg 0) "%s%s"))
          (let ((deactivate-mark nil)
                (inhibit-read-only t))
            (with-current-buffer "*Messages*"
              (goto-char (point-max))
              (if (not (bolp))
                  (newline))
              (insert (current-time-microseconds))))))
    #+END_SRC

*** Disable compiler warnings
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq byte-compile-warnings nil)
    #+END_SRC
*** Allow answering 'Yes or No' prompts with Y or N
    #+BEGIN_SRC emacs-lisp :tangle yes
    (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC
*** Confirm exiting emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq confirm-kill-emacs 'y-or-n-p)
    #+END_SRC
*** Enable better interop with OS clipboard
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq save-interprogram-paste-before-kill t)
    #+END_SRC
*** Enforce newline at end of files
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq require-final-newline t)
    #+END_SRC
*** Hide cursor in non-focussed windows
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq cursor-in-non-selected-windows nil)
    #+END_SRC
*** Persist highlight in non-focussed windows
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq highlight-nonselected-windows t)
    #+END_SRC
*** Disable using tabs as indents
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq-default indent-tabs-mode nil)
    #+END_SRC
*** Enable use of the clipboard
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq select-enable-clipboard t)
    #+END_SRC
*** Allow overwriting selected text
    #+BEGIN_SRC emacs-lisp :tangle yes
    (delete-selection-mode 1)
    #+END_SRC
*** Always focus the =*Help*= buffer when it opens
    I prefer the =*Help*= buffer to gain focus when it opens
    so I can hit =q= to close it and go back to where I was.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq help-window-select t)
    #+END_SRC
**** Disable debug-on-error once we've loaded
     This is useful during the start-up process,
     but becomes a nuisance once we're in edit mode.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'emacs-startup-hook
       (lambda ()
         (setq debug-on-error nil)))
     #+END_SRC
*** Increase the amount of data Emacs reads from processes
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq read-process-output-max (* 1024 1024)) ;; 1mb
    #+END_SRC
** Basic settings
*** UTF-8 everywhere
    Note: moved to =early-init=
    #+BEGIN_SRC emacs-lisp :tangle no
      (set-charset-priority 'unicode)
      (setq locale-coding-system   'utf-8)   ; pretty
      (set-terminal-coding-system  'utf-8)   ; pretty
      (set-keyboard-coding-system  'utf-8)   ; pretty
      (set-selection-coding-system 'utf-8)   ; please
      (prefer-coding-system        'utf-8)   ; with sugar on top
      (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
    #+END_SRC
*** Environment
**** Flag that emacs is active (for use with tmux)
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setenv "INSIDE_EMACS" "1")
     #+END_SRC
**** Pick up =PATH= from =zsh=
     #+BEGIN_SRC emacs-lisp :tangle yes
       (defun my/configure-path ()
         (let ((path (shell-command-to-string ". ~/.zshrc; echo -n $PATH")))
           (setenv "PATH" path)
           (setq exec-path
                 (append
                  (split-string-and-unquote path ":")
                  exec-path))))

       (add-hook 'emacs-startup-hook 'my/configure-path)
     #+END_SRC
**** Enable direnv
     =direnv= is a great tool for managing local environment during
     development. This package integrates =direnv= with Emacs so that
     programs started from within emacs, such as inferior shells,
     linters, compilers, and test runners, will be looked up in the
     correct =$PATH=, and will be started with the correct environment
     variables set.
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package direnv
         :delight
         :config
         (add-hook 'emacs-startup-hook (direnv-mode)))
     #+END_SRC
**** =exec-path-from-shell=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package exec-path-from-shell
       :if (memq window-system '(mac ns))
       :delight
       :config
         (with-eval-after-load 'exec-path-from-shell-initialize))
     #+END_SRC
**** ~Ensure system packages deps are available~
     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package use-package-ensure-system-package)
     #+END_SRC
**** Add =asdf= to exec path
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'exec-path (expand-file-name "~/.asdf/shims"))
     #+END_SRC
** Interface
*** macOS fixes
**** Use native full-screen
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq ns-use-native-fullscreen t)
     #+END_SRC
**** Don't open new windows from terminal
     This stops new windows (frames) opening when
     calling emacs from the terminal with a filename
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq ns-pop-up-frames nil)
     #+END_SRC
**** Try to fix colours
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq ns-use-srgb-colorspace t)
     #+END_SRC
*** Theme
    My personal theme: https://github.com/OldhamMade/leiptr-them
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package leiptr-theme
      :straight (leiptr :type git :host github :repo "OldhamMade/leiptr-theme")
      :init (load-theme 'leiptr t))
    #+END_SRC
*** Font: SanFranciscoMono
    This has been set in =early-init.el=, but repeated here for completeness.
    #+BEGIN_SRC emacs-lisp :tangle no
    (set-face-attribute 'default nil :font "SFMono Nerd Font:pixelsize=10:weight=normal:slant=normal:width=normal:spacing=100:scalable=true:hinting=true")
    #+END_SRC
*** Enable Emoji
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package unicode-fonts
       :ensure t
       :config
         (when (member "Apple Color Emoji" (font-family-list))
           (set-fontset-font t 'symbol "Apple Color Emoji" nil 'prepend))
         (unicode-fonts-setup))
     #+END_SRC
*** Show a visual bell
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package mode-line-bell
      :defer
      :config
        (setq mode-line-bell-flash-time 0.4)
        (add-hook 'emacs-startup-hook 'mode-line-bell-mode))
    #+END_SRC
**** Show a bell when using the cursors too much
     I'd like to use more "jump" commands, but I rely on
     arrow keys too much. This should hopefully remove that
     reliance.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package annoying-arrows-mode
       :defer
       :config
         (add-hook 'emacs-startup-hook 'global-annoying-arrows-mode))
     #+END_SRC
*** Install =popup= for packages that require it
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package popup)
    #+END_SRC
*** Better help
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package helpful
      :defer
      :bind (("C-h f" . helpful-callable)
             ("C-h v" . helpful-variable)
             ("C-h k" . helpful-key)))
    #+END_SRC
** Key bindings
*** macOS modifier keys
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq mac-command-modifier 'alt
          mac-option-modifier 'meta
          mac-command-modifier 'hyper
          mac-right-option-modifier nil)
    #+END_SRC
*** macOS standard keybindings
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-keys*
       ;; undo/redo handled by alternative package
       ; ("H-z" . undo)
       ; ("H-Z" . redo)
       ;; moving around
       ("<next>" . (lambda () (interactive)
                     (condition-case nil (scroll-up)
                       (end-of-buffer (goto-char (point-max))))))
       ("<prior>" . (lambda () (interactive)
                      (condition-case nil (scroll-down)
                        (beginning-of-buffer (goto-char (point-min))))))
       ;; Select all
       ("H-a" . mark-whole-buffer)
       ;; cut
       ("H-x" . kill-region)
       ;; copy
       ("H-c" . kill-ring-save)
       ;; paste
       ("H-v" . yank)
       ;; open
       ("H-o" . find-file)
       ;; save
       ("H-s" . save-buffer)
       ;;  close
       ("H-w" . (lambda ()
                  (interactive)
                  (my-kill-buffer
                   (current-buffer))))
       ;; quit
       ("H-q" . save-buffers-kill-emacs)
       ;; minimise
       ("H-m" . iconify-frame)
       ;; hide
       ("H-h" . ns-do-hide-emacs)
       ;; jump to beginning of line
       ("H-<left>" . beginning-of-line)
       ;; jump to end of line
       ("H-<right>" . end-of-line)
       )
    #+END_SRC
*** Add =general= for more convenient key definitions
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package general)
    #+END_SRC
*** Tools for finding free keys
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package free-keys
      :defer)
    #+END_SRC
** Navigation
*** =which-key=
    =which-key= is a minor mode for Emacs that displays the key bindings
    following your currently entered incomplete command (a prefix) in
    a popup. For example, after enabling the minor mode if you enter
    =C-x= and wait for the default of 1 second the minibuffer will
    expand with all of the available key bindings that follow =C-x= (or
    as many as space allows given your settings).

    I'm using =which-key= to try and remove my reliance on custom
    Hydras with =H-<key>= bindings.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package which-key
      :config
      (setq which-key-idle-delay .4
            which-key-side-window-location 'bottom
            which-key-side-window-max-height 0.25)
      (which-key-mode 1))
    #+END_SRC
*** =hercules=
    =hercules.el= lets us call any group of related command
    sequentially with no prefix keys, while showing a handy
    =which-key=-style popup to remember the bindings for those
    commands.

    I'm using this to remove my reliance on custom Hydras from my
    previous config.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package hercules
      :defer)
    #+END_SRC
*** =amx=
    =amx= is an alternative interface for M-x in Emacs. It provides
    several enhancements over the ordinary execute-extended-command,
    such as prioritizing your most-used commands in the completion
    list and showing keyboard shortcuts, and it supports several
    completion systems for selecting commands, such as ido and ivy.

    I'm trialing =amx= as an alternative to =smex=.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package amx
      :defer)
    #+END_SRC
*** =flx=
    Whenever I do searches I prefer the fuzzy-matching style,
    similar to =fzf= on the commandline. =flx= provides similar
    functionality in emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flx
      :defer)
    #+END_SRC
*** Ivy/Counsel/Swiper
    =ivy= is a generic completion mechanism for Emacs. While it operates
    similarly to other completion schemes such as icomplete-mode, Ivy
    aims to be more efficient, smaller, simpler, and smoother to use
    yet highly customizable.

    Counsel takes this further, providing versions of common Emacs
    commands that are customised to make the best use of ivy.

    And Swiper is an alternative to isearch that uses ivy to show an
    overview of all matches.

    I'm trialing Ivy/Counsel/Swiper as a replacement for
    =ido= + =smex= and =isearch=.

**** =ivy=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy
       :delight
       :defer
       :init
         (ivy-mode 1)
       :bind
         (("C-x C-b" . ivy-switch-buffer)
          ("C-x b" . ivy-switch-buffer)
          ("C-c i r" . ivy-resume))
       :config
         (setq ivy-use-virtual-buffers t
               enable-recursive-minibuffers t
               ivy-height 10
               ivy-wrap t
	       ivy-extra-directories nil
               ;; disable ^ prefix
               ivy-initial-inputs-alist nil
               ;; enable fuzzy matches eveywhere
	       ivy-re-builders-alist
	         '((swiper . ivy--regex-plus)
               (t . ivy--regex-fuzzy))  ;; fuzzy-search everywhere
	       ivy-count-format "(%d/%d) ")
         ;; Use C-j for immediate termination with the current value, and RET
         ;; for continuing completion for that directory. This is the ido
         ;; behaviour.
         ;; TODO: Remove me, to get used to proper ivy usage
         (general-define-key
           :keymaps 'ivy-minibuffer-map
             "C-j" 'ivy-immediate-done
             "RET" 'ivy-alt-done))
     #+END_SRC
**** =counsel=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel
       :delight
       :defer
       :after (ivy)
       :bind
         ((:map counsel-describe-map ("M-." . counsel-find-symbol))
          ("C-x C-f" . counsel-find-file)
          ("C-M-f" . counsel-rg)
          ("C-M-r" . counsel-recentf)
          ("C-x m" . counsel-mark-ring))
       :init
         (require 'amx)
         (counsel-mode)
       :config
         (setq counsel-find-file-ignore-regexp (regexp-opt '("./" "..")))
         (setq counsel-fzf-cmd "fd -H | fzf -f \"%s\"")
         (add-to-list 'ivy-re-builders-alist '(counsel-ag-function . ivy--regex))
         (add-to-list 'ivy-re-builders-alist '(counsel-fzf-function . ivy--regex))
         (add-to-list 'ivy-sort-functions-alist '(counsel-fzf-function . nil)))
     #+END_SRC
**** =swiper=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package swiper
       :delight
       :defer)
     #+END_SRC
**** =ivy-rich=
     =ivy-rich= is a more friendly interface for ivy, providing inline help
     and other "rich" data.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy-rich
       :after (ivy counsel)
       :config
       (ivy-rich-mode 1))
     #+END_SRC
*** Projectile

    Automagically interact with "projects"; git, mercurial, bazaar, and darcs repos
    are seen as projects by default.

**** =projectile=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package projectile
       :delight
       :defer
       :custom
       (projectile-enable-caching t)
       :config
       (defun get-projectile-root ()
         "Return path `matcha-projectile' can print in heading."
         (if (projectile-project-p)
             (file-name-nondirectory
              (directory-file-name
               (file-name-directory (projectile-project-root))))
           "Not in Project"))
       )

       (add-hook 'emacs-startup-hook (lambda () (projectile-mode +1)))
     #+END_SRC
**** Integrate =projectile= with =counsel=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel-projectile
       :delight
       :after
         (counsel projectile)
       :init
         (setq projectile-completion-system 'ivy
               projectile-switch-project-action 'projectile-vc)
       :config
         (general-define-key
           :keymaps 'projectile-mode-map
           "C-c p" 'projectile-command-map)
         (counsel-projectile-mode))
     #+END_SRC
**** Custom keybindings
     #+BEGIN_SRC emacs-lisp :tangle yes
     (general-def
       :keymaps 'projectile-command-map
       "A" 'projectile-add-known-project
       "K" 'projectile-remove-known-project
       "DEL" 'projectile-cleanup-known-projects)
     #+END_SRC

** Minibuffer
*** Disable ability to overwrite minibuffer prompt
    This stops the cursor entering the prompt text in the minibuffer
    when using shortcuts such as CTRL-A.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq minibuffer-prompt-properties
            '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
    #+END_SRC
*** Enable recursive editing

    We can make the minibuffer much more useful by enabling recursive
    usage. This means that when the minibuffer is active we can still call
    commands that require the minibuffer.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq enable-recursive-minibuffers t)
    #+END_SRC

    With this setting enabled, it's easy to lose track of whether we're
    in a recursive minibuffer or not. We display the recursion level in
    the minibuffer to avoid confusion.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (minibuffer-depth-indicate-mode 1)
    #+END_SRC

*** Minibuffer "shortcuts"

    When selecting a file to visit, // in the path will mean /
    (root) and ~ will mean $HOME regardless of preceding text

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq file-name-shadow-tty-properties '(invisible t))
    #+END_SRC

    Dim the part of the path that will be replaced.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (file-name-shadow-mode 1)
    #+END_SRC
** Modeline
*** Ensure buffer names are unique
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/load-uniquify ()
        (require 'uniquify)
        (setq uniquify-buffer-name-style 'forward))

      (add-hook 'emacs-startup-hook 'my/load-uniquify)
    #+END_SRC
*** Display total lines in file
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defvar my-mode-line-buffer-line-count nil)
      (make-variable-buffer-local 'my-mode-line-buffer-line-count)

      (setq-default mode-line-format
                    '("  " mode-line-modified
                      (list 'line-number-mode "  ")
                      (:eval (when line-number-mode
                               (let ((str "L%l"))
                                 (when (and (not (buffer-modified-p)) my-mode-line-buffer-line-count)
                                   (setq str (concat str "/" my-mode-line-buffer-line-count)))
                                 str)))
                      "  %p"
                      (list 'column-number-mode "  C%c")
                      "  " mode-line-buffer-identification
                      "  " mode-line-modes))

      (defun my-mode-line-count-lines ()
        (setq my-mode-line-buffer-line-count (int-to-string (count-lines (point-min) (point-max)))))

      (add-hook 'find-file-hook 'my-mode-line-count-lines)
      (add-hook 'after-save-hook 'my-mode-line-count-lines)
      (add-hook 'after-revert-hook 'my-mode-line-count-lines)
      (add-hook 'dired-after-readin-hook 'my-mode-line-count-lines)
    #+END_SRC
** Highlights
*** Indentation
    Note: using =:hooks= keyword causes issues because this is a minor-mode.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-indentation
      :delight
      :config
        (set-face-background 'highlight-indentation-face "#222")
        (add-hook 'org-mode-hook 'highlight-indentation-mode)
        (add-hook 'prog-mode-hook 'highlight-indentation-mode)
        (add-hook 'yaml-mode-hook 'highlight-indentation-mode))
    #+END_SRC
*** Delimiters
**** Show paren pairs
     I want to see the paren matches, but I don't want to be too
     distracted by them.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq show-paren-delay 0
           show-paren-style 'parenthesis)
     (set-face-background 'show-paren-match "#456")
     (set-face-foreground 'show-paren-match "#cde")
     (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
     (show-paren-mode t)
     #+END_SRC
**** Show delimiters with differing, paired colours
     Note: using =:hooks= keyword causes issues because this is a minor-mode.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package rainbow-delimiters
       :delight
       :config
         (add-hook 'org-mode-hook 'rainbow-delimiters-mode)
         (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
         (add-hook 'sass-mode-hook 'rainbow-delimiters-mode))
     #+END_SRC

*** Variables
    Rainbow identifiers subtly changes the look of variables, to make
    them a little easier to visually search

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package rainbow-identifiers
        :delight
        :defer
        :config
          (add-hook 'prog-mode-hook (lambda ()
                                      (unless (eq major-mode 'js2-mode)
                                        (rainbow-identifiers-mode)))))
    #+END_SRC
*** Highlight trailing whitespace
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq-default show-trailing-whitespace t)
    #+END_SRC
**** Disable for certain modes & minibuffer
     Certain modes, like =shell-mode=, and the minibuffer tend to
     leave trailing space that is annoying to see.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (dolist (hook '(special-mode-hook
                     term-mode-hook
                     comint-mode-hook
                     compilation-mode-hook
                     minibuffer-setup-hook))
       (add-hook hook
         (lambda () (setq show-trailing-whitespace nil))))
     #+END_SRC
*** Lines that go over 80 chars for prog/web modes
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/load-whitespace ()
        (require 'whitespace)
        (setq whitespace-line-column 80) ;; limit line length
        (setq whitespace-style '(face lines-tail))
        (global-whitespace-mode +1))

      (add-hook 'prog-mode-hook 'my/load-whitespace)
      (add-hook 'web-mode-hook 'my/load-whitespace)
    #+END_SRC
*** Colour references, displaying the colour referenced
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package rainbow-mode
      :delight
      :hook (sass-mode css-mode emacs-lisp-mode))
    #+END_SRC
*** Changes to the buffer caused by commands such as ‘undo’, ‘yank’/’yank-pop’, etc.
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package volatile-highlights
      :delight
      :defer
      :config (add-hook 'emacs-startup-hook (lambda ()(volatile-highlights-mode t))))
    #+END_SRC
*** Keywords like TODO/FIXME/etc
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package hl-todo
      :defer
      :config (add-hook 'emacs-startup-hook 'global-hl-todo-mode))
    #+END_SRC
*** Syntax highlighting by default
    Wait until emacs has loaded, then enable syntax highlighting
    everywhere
    #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'emacs-startup-hook
      (lambda () (global-font-lock-mode 1)))
    #+END_SRC
*** Prettify symbols
    #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'emacs-startup-hook
      (lambda () (global-prettify-symbols-mode +1)))
    #+END_SRC
*** Change cursor dynamically, depending on the context
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package cursor-chg
      :init
        (setq curchg-default-cursor-type 'box
              curchg-idle-cursor-type 'hollow
              curchg-default-cursor-color "white"
              curchg-input-method-cursor-color "red")
      :config
        (add-hook 'emacs-startup-hook (lambda () (change-cursor-mode 1))))
    #+END_SRC
** Files
*** Set a large =recentf= list, after startup
    #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'emacs-startup-hook
      (lambda ()
        (setq recentf-max-menu-items 100
              recentf-max-saved-items 100)
        (recentf-mode 1)
        ))
    #+END_SRC
*** Enable auto-save of files as they are edited, so that no changes are lost
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package super-save
      :delight
      :defer
      :config
        (setq super-save-auto-save-when-idle t)  ;; autosave to the real file
        (setq super-save-idle-duration 15)  ;; autosave idle wait
        (setq auto-save-default nil)  ;; disable autosave to backup file
        (add-hook 'emacs-startup-hook (lambda () (super-save-mode +1))))
    #+END_SRC
*** Backup files to a local directory.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq auto-save-file-name-transforms `((".*" ,"~/.emacs.d/auto-backup/" t)))
    (setq
     backup-by-copying t      ; don't clobber symlinks
     backup-directory-alist
     '(("." . "~/.emacs.d/auto-backup/"))    ; don't litter my fs tree
     delete-old-versions t
     kept-new-versions 6
     kept-old-versions 2
     version-control t)       ; use versioned backups
    #+END_SRC
*** Disable annoying lockfiles
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq create-lockfiles nil)
    #+END_SRC
*** Always append a new line to the file
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq require-final-newline t)
    #+END_SRC
*** Clean whitespace intelligently on key-press
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package shrink-whitespace
      :delight
      :defer
      :config (general-define-key (kbd "<C-M-backspace>") 'shrink-whitespace))
    #+END_SRC

*** Copy Filename to Clipboard
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun copy-file-name-to-clipboard ()
      "Copy the current buffer file name to the clipboard."
      (interactive)
      (let ((filename (if (equal major-mode 'dired-mode)
                          default-directory
                        (buffer-file-name))))
        (when filename
          (kill-new filename)
          (message "Copied buffer file name '%s' to the clipboard." filename))))
    #+END_SRC
*** Reveal in Finder
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package reveal-in-osx-finder
      :delight
      :defer)
    #+END_SRC
** Buffers
*** Initial buffer major mode: text
    Switch to =text-mode= once startup has completed.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq initial-major-mode 'fundamental-mode)
    (add-hook 'emacs-startup-hook
      (lambda ()
        (setq initial-major-mode 'text-mode)))
    #+END_SRC

*** New Empty Buffer
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun new-empty-buffer ()
      "Create a new buffer called untitled(<n>)"
      (interactive)
      (let ((newbuf (generate-new-buffer-name "untitled")))
        (switch-to-buffer newbuf)))

    (general-define-key "H-n" 'new-empty-buffer)
    #+END_SRC

*** Make the =*scratch*= buffer persistent across sessions
    #+BEGIN_SRC  emacs-lisp :tangle yes
    (use-package persistent-scratch
      :config
      (setq persistent-scratch-save-file (expand-file-name "~/Dropbox/.emacs.persist/.scratch"))
      (add-hook 'emacs-startup-hook 'persistent-scratch-setup-default))

    (defun my/set-scratch-as-text ()
      (with-current-buffer (get-buffer "*scratch*")
        (let ((mode "text-mode"))
          (message "Setting scratch to text-mode")
          (funcall (intern mode)))))

    (defadvice persistent-scratch-restore (after advice-persistent-scratch-restore activate)
      (my/set-scratch-as-text))

      ;; yas-reload-all unfortunately triggers `persistent-scratch-setup-default`
      ;; again, resetting the scratch to fundamental-mode, so advising here too.
      ;; (defadvice yas-reload-all (after advice-yas-reload-all activate)
      ;;  (my/set-scratch-as-text))
    #+END_SRC

*** Bury special buffers instead of killing
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq bury-buffer-names '("*scratch*" "*Messages*" "*dashboard*"))

    (defun kill-buffer-query-functions-maybe-bury ()
      "Bury certain buffers instead of killing them."
      (if (member (buffer-name (current-buffer)) bury-buffer-names)
          (progn
            (kill-region (point-min) (point-max))
            (bury-buffer)
            nil)
        t))

    (add-hook 'kill-buffer-query-functions 'kill-buffer-query-functions-maybe-bury)

    (defun my-kill-buffer (buffer)
      "Protect some special buffers from getting killed."
      (interactive (list (current-buffer)))
      (if (member (buffer-name buffer) bury-buffer-names)
          (call-interactively 'bury-buffer buffer)
        (kill-buffer buffer)))
    #+END_SRC

*** Kill all buffers except current
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/kill-all-buffers-except-current ()
      "Kill all buffers except current buffer."
      (interactive)
      (let ((current-buf (current-buffer)))
        (dolist (buffer (buffer-list))
          (set-buffer buffer)
          (unless (eq current-buf buffer)
            (kill-buffer buffer)))))
    (general-define-key (kbd "C-x K") 'my/kill-all-buffers-except-current)
    #+END_SRC

*** Switching buffers
*** Copy buffer path to kill ring
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun copy-full-path-to-kill-ring ()
      "copy buffer's full path to kill ring"
      (interactive)
      (when buffer-file-name
        (kill-new (file-truename buffer-file-name))))
    #+END_SRC

*** Echo buffer path
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun describe-variable-short (var)
      (interactive "vVariable: ")
      (message (format "%s: %s" (symbol-name var) (symbol-value var))) )

    (defun get-buffer-path ()
      "print the buffer path in the mini buffer"
      (interactive)
      (when buffer-file-name
        (kill-new (file-truename buffer-file-name))
        (message (format "Path: %s (copied to kill-ring)" (file-truename buffer-file-name)))
        ))
    #+END_SRC

** Moving around
*** Enable subword mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (global-subword-mode 1)
    #+END_SRC
*** Make the =goto-map= keymap better
    =M-g=, the =goto-map=, is somewhat limited. Since we have =avy=
    and it's friends, let's add further options.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (general-define-key
      :keymaps 'goto-map
      "c" 'avy-goto-char-timer
      "[" 'beginning-of-buffer
      "]" 'end-of-buffer
      "'" '("previous points" . pop-global-mark)
      "." '("previous M-. tag" . pop-tag-mark))
    #+END_SRC

    And now let's bind =C-;=, a more comfortable key combo which is
    generally unused, to =goto-map=.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (general-define-key
      "C-;" (general-simulate-key "M-g"))
    #+END_SRC
*** Move Where I Mean
    =C-a= and =C-e= normally moves the cursor to the beginning/end of
    the line unconditionally.

    =mwim= is more useful, as it moves to the first non-whitespace
    character if we're already at the beginning of the line. Repeated
    use of =C-a= toggles between these two positions.

    =C-e= will toggle to the end of the line ignoring comments, or to
    the true end of the line.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package mwim
      :delight
      :bind (("C-a" . mwim-beginning)
             ("C-e" . mwim-end)
             ("H-<left>" . mwim-beginning)
             ("H-<right>" . mwim-end)))
    #+END_SRC
*** Jumping around with =avy= and friends
**** =avy=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package avy
       :delight
       :general
         (:keymaps 'goto-map
          "c" 'avy-goto-char-timer
          "w" 'avy-goto-word-1
          "l" 'avy-goto-line)
       :config (setq avy-all-windows nil))
     #+END_SRC
*** Jump back to the last edit
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package goto-last-change
      :delight
      :general
        (:keymaps 'goto-map
         "-" 'goto-last-change))
    #+END_SRC
*** Quickly jump between other symbols found at point
    Smart Scan will try to infer the symbol your point is on and let
    you jump to other, identical, symbols elsewhere in your current
    buffer with a single key stroke.

    Use =M-n= and =M-p= move between symbols, and =M-'= to replace all
    symbols in the buffer matching the one under point.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package smartscan
      :hook (emacs-startup . (lambda () (smartscan-mode 1))))
    #+END_SRC
** Editing
*** Use [[http://www.dr-qubit.org/emacs.php#undo-tree][=undo-tree]] in place of standard undo/redo
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package undo-tree
      :delight
      :defer
      :config (add-hook 'emacs-startup-hook 'global-undo-tree-mode))
    #+END_SRC
*** Undo/redo
**** Add =undo-fu= for better undo behaviour
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package undo-fu
       :straight (undo-fu :type git :host gitlab :repo "ideasman42/emacs-undo-fu")
       :defer
       :delight
       :init
         (global-unset-key (kbd "H-z"))
         (global-unset-key (kbd "H-Z"))
       :general
         ("H-z" #'undo-fu-only-undo)
         ("H-Z" #'undo-fu-only-redo))
     #+END_SRC
**** Add =undo-fu-session= for history
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package undo-fu-session
       :straight (undo-fu-session :type git :host gitlab :repo "ideasman42/emacs-undo-fu-session")
       :delight
       :after undo-fu
       :init
         (setq undo-fu-session-directory (expand-file-name "~/Dropbox/.emacs.persist/.undohist")
               undo-fu-session-incompatible-files
               '("COMMIT_EDITMSG"
                 "NOTES_EDITMSG"
                 "MERGE_MSG"
                 "TAG_EDITMSG"
                 "\\.gpg\\'"
                 "/tmp"
                 file-remote-p)))
     #+END_SRC
*** Unfill
    Unfill adds the inverse of fill-paragraph/-region.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package unfill
      :delight
      :defer)
    #+END_SRC
*** Indents
**** Enable automatic indenting
     #+BEGIN_SRC emacs-lisp :tangle yes
     (electric-indent-mode +1)
     #+END_SRC
**** Set tab width to 4 for all buffers
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default tab-width 4)
     #+END_SRC
*** Cursors
**** Multiple cursors
     Allows editing with multiple points on the screen.
***** Base package
      #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package multiple-cursors
        :delight
        :config
        (general-def
          :prefix-map 'my/mc-map
          "n" #'mc/mark-next-like-this
          "p" #'mc/mark-previous-like-this
          "j" #'mc/skip-to-next-like-this
          "-" #'mc/skip-to-previous-like-this
          "a" #'mc/mark-all-like-this
          "N" #'mc/mark-next-symbol-like-this
          "P" #'mc/mark-previous-symbol-like-this
          "A" #'mc/mark-all-symbols-like-this
          "." #'mc/mark-all-dwim
          "1" #'mc/insert-numbers
          "L" #'mc/insert-letters
          "l" #'mc/edit-lines
          "s" #'mc/sort-regions
          "r" #'mc/reverse-regions
          )
        (hercules-def
          :toggle-funs #'my/mc-mode
          :keymap 'my/mc-map
          :transient t)
        (general-define-key
          :keymaps 'mc/keymap
          "<return>" nil)
        (general-define-key
          (kbd "C-c m") #'my/mc-mode))
      #+END_SRC
***** FIXME =ace-mc=
      =ace-mc= makes it really easy to add and remove multiple cursors
      using ace jump mode.

      #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ace-mc
        :after (multiple-cursors)
        :delight
        :bind ("M-M m" . ace-mc-add-multiple-cursors))
      #+END_SRC
**** Smart regions
     Smart region guesses what you want to select by one command:

     - If you call this command multiple times at the same position, it
       expands the selected region (with `er/expand-region').
     - Else, if you move from the mark and call this command, it selects
       the region rectangular (with `rectangle-mark-mode').
     - Else, if you move from the mark and call this command at the same
       column as mark, it adds a cursor to each line (with `mc/edit-lines').

     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package smart-region
       :after (multiple-cursors)
       :hook (emacs-startup . smart-region-on))
     #+END_SRC
**** Remember cursor position when reopening files
     #+BEGIN_SRC emacs-lisp :tangle yes
     (save-place-mode 1)
     (setq save-place-forget-unreadable-files nil)
     #+END_SRC
**** Expanding regions
     I use expand region a lot. =M-[= feels like a good binding, with
     the mental connection of "open" (expand) and conversely =M-]= as
     "close" (contract).
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package expand-region
       :delight
       :bind (("M-[" . er/expand-region)
              ("M-]" . er/contract-region)))
     #+END_SRC
     FIXME: elixir mode should have expansions similar to ruby-mode
       ;:config
       ;(er/enable-mode-expansions 'elixir-mode 'er/add-ruby-mode-expansions)
*** Braces
**** Auto-pair braces
     Emacs 24.4+ comes with =electric-pair-mode= which matches =autopair=
     in terms of functionality.

     I disable it in the minibuffer as it usually just gets in the way there.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (electric-pair-mode t)
     (add-hook 'minibuffer-setup-hook (lambda () (electric-pair-mode -1)))
     (add-hook 'minibuffer-exit-hook (lambda () (electric-pair-mode t)))
     #+END_SRC
**** Embrace
     Add/Change/Delete pairs based on expand-region
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package embrace
       :delight
       :defer
       :general
         ("C-'" #'embrace-commander)
       :hook
         (ruby-mode . embrace-ruby-mode))
     #+END_SRC
*** Move text with =M-<up>= and =M-<down>=
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package move-text
      :delight "⥮"
      :config (add-hook 'emacs-startup-hook 'move-text-default-bindings))
    #+END_SRC
*** Crux: A Collection of Ridiculously Useful eXtensions
    =crux= bundles a few useful interactive commands to enhance your
    overall Emacs experience.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package crux
      :commands
        (crux-duplicate-current-line-or-region
         crux-smart-kill-line
         crux-rename-file-and-buffer
         crux-kill-other-buffers
         crux-capitalize-region
         crux-upcase-region
         crux-downcase-region)
      :bind (("M-D" . crux-duplicate-current-line-or-region)
             ("C-k" . crux-smart-kill-line)
             ("C-c R" . crux-rename-file-and-buffer)
             ("C-c K" . crux-kill-other-buffers)
             ("C-c c c" . crux-capitalize-region)
             ("C-c c u" . crux-upcase-region)
             ("C-c c l" . crux-downcase-region)
             )
      :config
        (crux-reopen-as-root-mode))
    #+END_SRC
**** Set title for whichkey prefix entry
     #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key mode-specific-map "c" '("change case"))
     #+END_SRC
*** Whitespace
**** Delete trailing whitespace
     #+BEGIN_SRC emacs-lisp :tangle yes
     (general-define-key (kbd "C-c DEL") 'delete-trailing-whitespace)
     #+END_SRC
**** Allow inserting into whitespace-separated blocks
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dynamic-spaces
       :config (add-hook 'emacs-startup-hook (lambda () (dynamic-spaces-global-mode 1))))
     #+END_SRC
*** Inflection (camel/kebab/snake case)
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package string-inflection
      :bind ("M-C" . string-inflection-all-cycle))
    #+END_SRC
*** Up/Down-case DWIM
    #+BEGIN_SRC emacs-lisp :tangle yes
    (general-define-key (kbd "M-c") 'capitalize-dwim)
    (general-define-key (kbd "M-u") 'upcase-dwim)
    (general-define-key (kbd "M-l") 'downcase-dwim)
    #+END_SRC
** Spelling
*** =flyspell-correct-ivy=
    flyspell-correct is a package for distraction-free words
    correction with flyspell via a selected interface.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flyspell-correct-ivy
      :delight
      :bind ("C-M-;" . flyspell-correct-wrapper)
      :init
        (setq flyspell-correct-interface #'flyspell-correct-ivy))
    #+END_SRC
*** =ace-flyspell=
    Jump to and correct spelling errors using avy and flyspell.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ace-flyspell
      :delight
      :defer
      :config (add-hook 'emacs-startup-hook 'ace-flyspell-setup))
    #+END_SRC
** Search/replace
*** Highlight matches in query-replace mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq query-replace-highlight t)
    #+END_SRC
*** Add =deadgrep= for searching (faster than =grep=)
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package deadgrep
      :delight
      :init
        (defun config-editing--on-enter-deadgrep-edit-mode (&rest _)
          (message "Entering edit mode. Changes will be made to underlying files as you edit."))
        (defun config-editing--on-exit-deadgrep-edit-mode (&rest _)
          (when (derived-mode-p 'deadgrep-edit-mode)
            (message "Exiting edit mode.")))
      :general
        ("C-c d" 'deadgrep)
      :config
        (advice-add #'deadgrep-edit-mode :after #'config-editing--on-enter-deadgrep-edit-mode)
        (advice-add #'deadgrep-mode :before #'config-editing--on-exit-deadgrep-edit-mode))

    (general-def
      :keymaps 'deadgrep-mode-map
      "e" 'deadgrep-edit-mode
      ;; TODO: find some way to trigger these (push-button?)
      ;; "d" 'deadgrep--directory
      ;; "f" 'deadgrep--file-type
      ;; "c" 'deadgrep--case
      ;; "t" 'deadgrep--search-type
      ;; "s" 'deadgrep--search-term
      )

    (general-def
      :keymaps 'deadgrep-edit-mode-map
      "<escape>" 'deadgrep-mode)
    #+END_SRC
*** Display 'current match/total matches' in the mode-line in various search modes
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package anzu
      :delight
      :defer
      :config (add-hook 'emacs-startup-hook (lambda () (global-anzu-mode +1))))
    #+END_SRC
*** Synonym injection
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package synosaurus
      ; doesn't work with emacs-plus
      ;:ensure-system-package
      ;  (wn . wordnet)
      :commands (synosaurus-mode
                 synosaurus-lookup
                 synosaurus-choose-and-replace)
      :bind ("C-c S" . synosaurus-choose-and-replace)
      :init
      (setq synosaurus-backend 'synosaurus-backend-wordnet
            synosaurus-choose-method 'popup))
    #+END_SRC
*** =ace-isearch=
    A minor mode which combines =isearch=, =avy= and =swiper=.

    I have this configured to skip isearch and go from avy to swiper.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ace-isearch
      :defer
      :delight
      :config
        (custom-set-variables
          '(ace-isearch-input-length 2)
          '(ace-isearch-jump-delay 1)
          '(ace-isearch-function 'avy-goto-char)
          '(ace-isearch-use-jump 'printing-char)))

    (add-hook 'emacs-startup-hook (lambda () (global-ace-isearch-mode +1)))
    #+END_SRC
*** Visual regexp
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package visual-regexp
      :delight
      :defer
      :after (multiple-cursors)
      :general
        ("C-c r" #'vr/replace)
        ("C-c q" #'vr/query-replace)
      :config
        (general-define-key
          :keymaps 'my/mc-map
          "q" #'vr/mc-mark))
    #+END_SRC
** Windows
*** Automatically balance windows when created
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package balanced-windows
      :delight
      :defer
      :config
      (balanced-windows-mode))
    #+END_SRC
*** Use =ace-window= to move around
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ace-window
      :delight
      :bind ("M-o" . ace-window)
      :config
        (ace-window-display-mode t)
        (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
              aw-dispatch-always t))
    #+END_SRC
*** Allow "zooming" a buffer to full-screen
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package zoom-window
      :init (custom-set-variables
             '(zoom-window-mode-line-color "DarkGreen"))
      :bind ("C-x C-z" . zoom-window-zoom))
    #+END_SRC
*** Perspectives (workspaces)
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package persp-projectile
      :defer
      :init (use-package perspective)
      :after (projectile)
      :hook (emacs-startup . persp-mode)
      :general
        (:keymaps 'perspective-map
         "x" 'projectile-persp-switch-project)
        ;; override projectile-switch-project since
        ;; we always want to be in a perspective
        (:keymaps 'projectile-command-map
         "p" 'projectile-persp-switch-project))
    #+END_SRC

*** Recover window split using =C-c <left>= with winner-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/load-winner-mode ()
      (winner-mode 1))
    (add-hook 'emacs-startup-hook 'my/load-winner-mode)
    #+END_SRC
** Version Control
*** Highlight diff in fringe
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package diff-hl
      :delight
      :defer
      :general
        (:keymaps 'goto-map
         "n" 'diff-hl-next-hunk
         "p" 'diff-hl-previous-hunk)
      :config
        (add-hook 'emacs-startup-hook (lambda () (global-diff-hl-mode 1))))
    #+END_SRC

*** Browse-at-remote
    =browse-at-remote= opens the current buffer at
    github/gitlab/bitbucket/stash/git.savannah.gnu.org/sourcehut
    from Emacs.

    It supports various kind of emacs buffer, like:
    - file buffer
    - dired buffer
    - magit-mode buffers representing code
    - vc-annotate mode (use get there by pressing C-x v g by default)

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package browse-at-remote
      :general ("C-c g g" 'browse-at-remote))
    #+END_SRC
*** Use =magit= and =forge= with git repositories
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package magit-todos
      :after (projectile magit))

    (use-package magit-gitflow
      :after (projectile magit))

    (use-package magit-diff-flycheck
      :after (projectile magit))

    (use-package magit
      :after projectile
      :bind ("C-x g" . magit-status)
      :commands (magit-status
                 magit-log
                 magit-commit
                 magit-stage-file)
      :hook ((magit-mode . turn-on-magit-gitflow))
      :config
      (setq magit-branch-arguments nil
            magit-branch-read-upstream-first 'fallback
            magit-diff-paint-whitespace t
            magit-diff-highlight-indentation (quote (("" . tabs)))
            magit-fetch-arguments (quote ("--prune"))
            magit-pull-arguments (quote ("--rebase"))
            magit-push-arguments (quote ("--set-upstream"))
            magit-log-arguments (quote ("--graph" "--color" "--decorate" "-n256")))
      (magit-todos-mode t)
      (transient-append-suffix 'magit-pull "C"
        '("A" "Autostash" "--autostash"))
      )

    (defun magit-set-repo-dirs-from-projectile ()
      "Set `magit-repository-directories' with known Projectile projects."
      (setq magit-repository-directories
            (mapcar (lambda (dir)
                      (cons dir 0))
                    (seq-filter (lambda (dir)
                                  (file-exists-p (expand-file-name ".git" dir)))
                                projectile-known-projects))))

    (with-eval-after-load 'projectile
      (magit-set-repo-dirs-from-projectile))

    (add-hook 'projectile-switch-project-hook
              #'magit-set-repo-dirs-from-projectile)
    (setq smerge-command-prefix "\C-c m")
    #+END_SRC
**** TODO reintroduce =smerge= keybindings
     I originally had the following magit hook, but without hydra
     it raises an error. Needs to be replaced with a General setup.
     #+BEGIN_SRC emacs-lisp :tangle no
     (magit-diff-visit-file . (lambda ()
                                        (when smerge-mode
                                          (my/smerge-hydra/body))))
     #+END_SRC
**** =smerge= keybindings
     #+BEGIN_SRC emacs-lisp :tangle yes
     (general-define-key
       :keymaps 'smerge-mode-map
       :prefix "C-c -"
       "" '(nil :which-key "smerge")
       "n" '(smerge-next :which-key "next")
       "p" '(smerge-prev :which-key "previous")
       "o" '(smerge-keep-lower :which-key "other (upper)")
       "m" '(smerge-keep-upper :which-key "mine (lower)")
       "u" '(smerge-keep-upper :which-key "upper (other)")
       "l" '(smerge-keep-lower :which-key "lower (mine)")
       )
     #+END_SRC
**** Add advice around branch naming to convert spaces to dashes
     #+BEGIN_SRC emacs-lisp :tangle yes
     (advice-add 'magit-whitespace-disallowed :around
       (lambda (orig-fun &rest args) (interactive) (insert "-")))
     #+END_SRC
** Org-mode
*** Tweaks
    These are tweaks to the built-in org-mode
**** stuff
     #+begin_#+BEGIN_SRC emacs-lisp :tangle yes
     ?
     #+END_SRC
     #+end_#+BEGIN_SRC
**** Ensure UTF-8
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-export-coding-system 'utf-8)
     #+END_SRC
**** Enable shift-selection
     Standard Emacs =S-<cursor>= commands conflict with Org’s use of
     =S-<cursor>= to change timestamps, TODO keywords, priorities, and
     item bullet types, etc. Since =S-<cursor>= commands outside of
     specific contexts do not do anything, Org offers the variable
     =org-support-shift-select= for customization. Org mode accommodates
     shift selection by:

       1. making it available outside of the special contexts where special
          commands apply, and
       2. extending an existing active region even if point moves across a
          special context.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-support-shift-select t)
     #+END_SRC
**** Add font styles to =DONE= lines
     It's useful to have titles like =TODO= and =DONE= hilight differently.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-fontify-done-headline t)
     #+END_SRC
**** =SRC= blocks
***** Style src blocks natively
      #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-src-fontify-natively t)
      #+END_SRC
***** Allow indenting natively within source blocks.
      #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-src-tab-acts-natively nil)
      #+END_SRC
***** Return to the previous "easy templates"
      #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'org-tempo)
      #+END_SRC
***** Additional templates
      Org-mode has "Easy Templates", here are some additions:
      #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'org-structure-template-alist
              '("S" . "#+BEGIN_SRC emacs-lisp :tangle yes\n?\n#+END_SRC"))
      #+END_SRC
**** Org-Capture
     #+BEGIN_SRC emacs-lisp :tangle yes
     (general-define-key
       "C-c o" 'org-capture)
     (setq org-default-notes-file "~/Dropbox/notes.org")
     (defvar my-org-capture-directory
       (expand-file-name "~/Dropbox/org")
       "Location for all org-mode capture files.")
     #+END_SRC
***** =doct=: Declarative Org Capture Templates
      #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package doct
        :ensure t
:after org
:init (setq org-capture-templates '())
  :config
   (setq til-categories
     '(
       ("Ack" "a")
       ("ASDF" "A")
       ("Elixir" "x")
       ("Emacs" "e")
       ("Git" "g")
       ("Magit" "M")
       ("Makefiles" "m")
       ("Phoenix" "p")
       ("Python" "P")
       ("Shell" "s")
       ("Tmux" "t")
       ))
   (setq idea-categories
     '(
       ("Open-Source Library" "o")
       ("Physical Product" "p")
       ("Web App" "w")
       ("iOS App" "i")
       ("macOS App" "m")
       ))
   (setq org-capture-templates
    (doct `(:group
             :empty-lines 1
             :children
             (("Tasks"
               :keys "t"
               :file ,(expand-file-name "tasks.org"  my-org-capture-directory)
               :clock-in t
               :clock-resume t
               :children
               (("Today" :keys "t" :type entry :headline "Uncategorized"
                 :datetree t :tree-type week :template "* TODO %?\n %i\n %a\n")
                ("Reading" :keys "r" :type entry :headline "Reading"
                 :template "* TODO %^{name}\n %a\n")
                ("Work" :keys "w" :type entry :headline "Work"
                 :template "* TODO %^{taskname}\n %a\n")))
              ("Blog"
               :keys "b"
               :file ,(expand-file-name "blog.org"  my-org-capture-directory)
               :type entry
               :template "* TODO %^{name}\n  %i%?\n  %a"
              )
              ("TIL"
               :keys "l"
               :file ,(expand-file-name "til.org"  my-org-capture-directory)
               :type entry
               :template "* TODO %^{name}\n  %i%?\n  %a"
               :children ,(cl-loop for (key value) in (sort til-categories (lambda (a b) (string< (car a) (car b))))
                   collect (list key :keys value :headline key))
              )
              ("Idea"
               :keys "i"
               :file ,(expand-file-name "project-ideas.org"  my-org-capture-directory)
               :type entry
               :template "* TODO %^{name}\n  %i%?\n  %a"
               :children ,(cl-loop for (key value) in (sort idea-categories (lambda (a b) (string< (car a) (car b))))
                   collect (list key :keys value :headline key))
              )
              ("Project"
               :keys "p"
               :file ,(defun my/project-todo-file ()
                        (let ((file (expand-file-name "TODO.org"
                                                      (when (functionp 'projectile-project-root)
                                                        (projectile-project-root)))))
                          (with-current-buffer (find-file-noselect file)
                            (org-mode)
                            ;; Set to UTF-8 because we may be visiting raw file
                            (setq buffer-file-coding-system 'utf-8-unix)
                            (when-let* ((headline (doct-get :headline)))
                              (unless (org-find-exact-headline-in-buffer headline)
                                (goto-char (point-max))
                                (insert "* " headline)
                                (org-set-tags (downcase headline))))
                            file)))
               :template (lambda () (concat "* %{todo-state} " (when (y-or-n-p "Link? ") "%A\n") "%?"))
               :todo-state "TODO"
               :children (("bug"           :keys "b" :headline "Bugs")
                          ("documentation" :keys "d" :headline "Documentation")
                          ("enhancement"   :keys "e" :headline "Enhancements")
                          ("feature"       :keys "f" :headline "Features")
                          ("optimization"  :keys "o" :headline "Optimizations")
                          ("miscellaneous" :keys "m" :headline "Miscellaneous")
                          ("security"      :keys "s" :headline "Security")))))
          )))
        #+END_SRC
*** Packages
**** Replace Org's bullets with something less noisy
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-bullets
       :after org
       :defer
       :init
         (setq org-bullets-bullet-list '("☰" "☷" "▶" "◆" "●" "✸"))
         (add-hook 'org-mode-hook #'org-bullets-mode))
     #+END_SRC

** Utility functions
   This section contains generally useful functions.
*** Paths & Dirs
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun parent-directory (dir)
      (unless (equal "/" dir)
        (file-name-directory (directory-file-name dir))))

    (defun find-file-in-hierarchy (current-dir fname)
      "Search for a file named FNAME upwards through the directory hierarchy, starting from CURRENT-DIR"
      (let ((file (concat current-dir fname))
            (parent (parent-directory (expand-file-name current-dir))))
        (if (file-exists-p file)
            file
          (when parent
            (find-file-in-hierarchy parent fname)))))

    (defun find-dir-in-hierarchy (current-dir dname)
      "Search for a dir named DNAME upwards through the directory hierarchy, starting from CURRENT-DIR"
      (let ((dir (concat current-dir dname))
            (parent (parent-directory (expand-file-name current-dir))))
        (if (file-directory-p dir)
            dir
          (when parent
            (find-dir-in-hierarchy parent dname)))))

    (defun find-include-dir ()
      "Search for the next available include dir from START."
      (let ((idir (find-dir-in-hierarchy (buffer-file-name) "include")))
        (if idir (concat "-I" idir) "")))
    #+END_SRC
** Programming
*** General enhancements
**** Jumping around
     =dumb-jump= is an Emacs "jump to definition" package for 40+
     languages that I find works really well.

     Here I add certain functions to my custom jump keymap.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dumb-jump
       :delight
       ; doesn't work with emacs-plus
       ;:ensure-system-package
       ;  (rg . ripgrep)
       :general
         (:keymaps 'goto-map
          "j j" 'dumb-jump-go
          "j b" 'dumb-jump-back
          "j o" 'dumb-jump-go-other-window)
       :config
        (setq dumb-jump-selector 'ivy
              dumb-jump-prefer-searcher 'rg
              dumb-jump-default-project "~/Projects"))
      #+END_SRC
**** DWIM with comments
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package comment-dwim-2
       :delight
       :general ("M-;" 'comment-dwim-2))
     #+END_SRC
**** URL encode/decode functions
     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun func-region (start end func)
       "run a function over the region between START and END in current buffer."
       (save-excursion
         (let ((text (delete-and-extract-region start end)))
           (insert (funcall func text)))))

     (defun url-encode (start end)
       "urlencode the region between START and END in current buffer."
       (interactive "r")
       (func-region start end #'url-hexify-string))

     (defun url-decode (start end)
       "de-urlencode the region between START and END in current buffer."
       (interactive "r")
       (func-region start end #'url-unhex-string))
     #+END_SRC
*** Language Server Protocol
**** lsp-mode
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package lsp-mode
       :commands lsp
       :delight
       :bind ("C-c h" . lsp-describe-thing-at-point)
       :hook
         (elixir-mode . lsp-deferred)
         (python-mode . lsp-deferred)
       :init
         (add-to-list 'exec-path "~/Projects/elixir/elixir-ls/release")
         (setq lsp-keymap-prefix "C-c l")
       :config
         (dolist (dir '("build$" "deps$"))
                 (push (concat "[/\\\\]" dir) lsp-file-watch-ignored))
         (setq
           lsp-auto-configure t
           lsp-auto-guess-root t
           lsp-eldoc-enable-hover nil
           lsp-enable-completion-at-point t
           lsp-enable-file-watchers t
           lsp-file-watch-threshold 10000
           lsp-keep-workspace-alive nil
           lsp-log-io t
           lsp-prefer-flymake nil
           )

         (add-hook 'before-save-hook
           (lambda () (when (eq major-mode 'elixir-mode)
                       (ignore-errors 'lsp-format-buffer))))
         (lsp-register-custom-settings
            '(("pyls.plugins.pyls_mypy.enabled" t t)
              ("pyls.plugins.pyls_mypy.live_mode" nil t)
              ;("pyls.plugins.pyls_black.enabled" t t)
              ;("pyls.plugins.pyls_isort.enabled" t t)
              ))
       )
     #+END_SRC
           lsp-eldoc-hook '(lsp-hover)
**** lsp-ui
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package lsp-ui
       :ensure t
       :commands lsp-ui-mode
       :after lsp-mode
       :config
         (setq
           lsp-ui-doc-enable nil
           lsp-ui-sideline-enable nil
           lsp-ui-sideline-show-hover nil
           lsp-ui-flycheck-enable t
           lsp-ui-sideline-ignore-duplicate t
           ))
     #+END_SRC
               lsp-ui-doc-enable t
               lsp-ui-doc-delay 1.0
               lsp-ui-doc-position 'bottom
**** lsp-ivy
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package lsp-ivy
       :commands lsp-ivy-workspace-symbol)
     #+END_SRC
**** eglot: Client for Language Server Protocol (LSP) servers
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package eglot
       :defer
       :delight
       :commands (eglot)
       :hook ((python-mode . eglot-ensure))
       :bind (:map eglot-mode-map
               ("C-c n" . eglot-rename) ; rename identifier
               ("C-c f" . eglot-format)))
     #+END_SRC
**** dap-mode
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dap-mode)
     #+END_SRC
*** Company mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company
      :config
        (add-hook 'emacs-startup-hook 'global-company-mode) ; Enable company-mode globally
        (setq company-idle-delay 0.1) ; Make Company open a little faster
        (define-key company-active-map (kbd "C-f") 'company-filter-candidates) ; allow filtering
        (define-key company-active-map (kbd "C-/") 'counsel-company) ; move to minibuffer
        )
    #+END_SRC
**** Add lsp backend
     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package company-lsp
       :after (company lsp-mode)
       :init (setq company-lsp-cache-candidates 'auto)
       :commands company-lsp
       :config
       (push 'company-lsp company-backends))
     #+END_SRC
*** Flycheck
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flycheck
      :defer
      :delight " ✓ "
      :config (add-hook 'emacs-startup-hook 'global-flycheck-mode))
    #+END_SRC
**** =flycheck-color-mode-line=
     An Emacs minor-mode for Flycheck which colors the mode line
     according to the Flycheck state of the current buffer.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck-color-mode-line
       :defer
       :after (flycheck)
       :config
         (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
     #+END_SRC
*** Code Folding
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package lsp-origami
      :defer
      :general
        ("C-c TAB" 'origami-recursively-toggle-node)
      :config
        (add-hook 'origami-mode-hook #'lsp-origami-mode))
    #+END_SRC
*** Elixir
    Elixir is fast becoming my primary programming language,
    so there's lots of tweaks and focus here
**** Add =ruby-end= to support the =end= keyword
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ruby-end
       :defer)
     #+END_SRC
**** Add =elixir-mode=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package elixir-mode
       :after (ruby-end elgot)
       :init
         (add-to-list
           'eglot-server-programs
             '(elixir-mode . ("sh" "~/Projects/elixir/elixir-ls/release/language-server.sh")))
         (add-to-list 'eglot-server-programs '(python-mode "pyls"))
       :delight
         (elixir-mode "[ex]")
         (ruby-end-mode "")
       :mode ("\\.exs?\\'" . elixir-mode)
       )
       ;(:config
       ;  (add-to-list 'eglot-server-programs
       ;    `(elixir-mode "~/Projects/elixir/elixir-ls/release/language-server.sh")))
     #+END_SRC
       :hook (company-mode lsp)
**** Add =exunit.el=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package exunit
       :straight (exunit :type git :host github :repo "ananthakumaran/exunit.el"))
     #+END_SRC
**** Add =inf-elixir=
     Pop open and interact with iEX
     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package inf-elixir
      :straight (inf-elixir :host github :repo "J3RN/inf-elixir")
      :functions
        (inf-elixir
         run-elixir
         inf-elixir-project
         inf-elixir-send-line
         inf-elixir-send-region
         inf-elixir-send-buffer))
     #+END_SRC
**** Add =flycheck-credo=
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck-credo
       :init
       (flycheck-credo-setup)
       :config
       (setq flycheck-elixir-credo-strict t))
     #+END_SRC
**** Define custom functions
***** =elixir-find-definition=
      #+BEGIN_SRC emacs-lisp :tangle yes
      (defun elixir-find-definition (var)
        (interactive "vDefinition: ")
        (lsp-find-definition var)
        )
      #+END_SRC
**** Define custom elixir keymaps
     Elixir keys start with =C-c e=.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (general-define-key
       :prefix "C-c e"
       "" '(nil :which-key "elixir")
       "t" '(exunit-verify-all :which-key "test project")
       "b" '(exunit-verify :which-key "test buffer")
       "u" '(exunit-verify-all-in-umbrella :which-key "test umbrella")
       "." '(exunit-verify-single :which-key "test at point")
       "r" '(exunit-rerun :which-key "rerun last")
       "F" '(xref-find-definitions :which-key "defs (here)")
       "f" '(xref-find-definitions-other-window :which-key "defs (other window)")
       "d" '(elixir-find-definition :which-key "jump to def")
       )
     #+END_SRC
**** Prettify elixir symbols
     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun elixir-mode-prettify-symbols-hook ()
       (setq-local
        prettify-symbols-alist
        (append
         '(("->" . ?→)
           ("=>" . ?⇒)
           ("<-" . ?←)
           ("<=" . ?⇐)
           (">=" . ?≥)
           ("=<" . ?≤)
           ("!=" . ?≠)
           ("fn" . ?ƒ))
         prettify-symbols-alist)))

     #+END_SRC
**** Add hooks
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'elixir-mode-hook 'elixir-mode-prettify-symbols-hook)
     (add-hook 'elixir-mode-hook 'ruby-block-mode)
     (add-hook 'elixir-mode-hook
               (lambda ()
                 (set (make-variable-buffer-local 'ruby-end-expand-keywords-before-re)
                      "\\(?:^\\|\\s-+\\)\\(?:do\\)")
                 (set (make-variable-buffer-local 'ruby-end-check-statement-modifiers)
                      nil)
                 (ruby-end-mode 1)
                 ))
     (eval-after-load 'elixir-mode '(require 'ruby-mode-expansions))
     #+END_SRC

**** Add support for .eex files
     Here we'll switch on =web-mode= so that we can edit HTML properly.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'auto-mode-alist '("\\.l?eex\\'" . web-mode))
     (setq web-mode-engines-alist
       '(("elixir" . "\\.l?eex\\'")))
     #+END_SRC

**** Add support for ExActor keywords
     #+BEGIN_SRC emacs-lisp :tangle yes
     (font-lock-add-keywords 'elixir-mode
       '(("\\<\\(defabcast\\|defabcastp\\|defcall\\|defcallp\\|defcast\\|defcastp\\|defhandlecall\\|defhandlecast\\|defhandleinfo\\|definit\\|defmulticall\\|defmulticallp\\|defstart\\|defstartp\\)\\>" 1 font-lock-keyword-face)))
     #+END_SRC

**** Configure code folding
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'hs-special-modes-alist
       '(elixir-mode
         ("\\(cond\\|quote\\|defmacro\\|defmacrop\\|defp\\|def\\|if\\) .*\\(do\\)" 2) "\\(end\\)" "#"
           nil nil))
     #+END_SRC

**** Reformat on save
     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/elixir-on-save-hook ()
       (add-hook 'before-save-hook
         (lambda ()
           (if (equal major-mode 'elixir-mode)
             (ignore-errors (elixir-format nil t))))))
     (add-hook 'elixir-mode-hook 'my/elixir-on-save-hook)
     #+END_SRC
*** Erlang
    I have to use the http://zotonic.com framework at my day job, so
    let's add erlang and some zotonic helpers
    #+BEGIN_SRC emacs-lisp :tangle yes
    (defun find-zotonic-include-dir ()
      "Search for the next available zotonic include dir from START."
      (let ((zdir (find-dir-in-hierarchy
        (file-name-directory buffer-file-name)
        (concat (file-name-as-directory "zotonic") "include"))))
          (if zdir (concat "-I" zdir) "")))

    (defun my/define-erlang-flychecker ()
      (flycheck-define-checker erlang-otp
        "An Erlang syntax checker using the Erlang interpreter."
        :command ("~/.asdf/shims/erlc" "-o" temporary-directory "-Wall"
                  (option-list "-I" flycheck-erlang-include-path)
                  (eval (find-zotonic-include-dir))
                  source)
        :error-patterns
        ((warning line-start (file-name) ":" line ": Warning:" (message) line-end)
         (error line-start (file-name) ":" line ": " (message) line-end))
        :modes erlang-mode))

    (defun erlang-mode-flycheck-hook ()
      (flycheck-select-checker 'erlang-otp)
      (flycheck-mode))

    (defun erlang-mode-compile-hook ()
      (require 'erlang-eunit)
      (when (projectile-project-p)
        (add-to-list 'erlang-compile-extra-opts (cons 'i  (projectile-project-p)))
        (add-to-list 'erlang-eunit-src-candidate-dirs (projectile-project-p))
        (add-to-list 'erlang-eunit-test-candidate-dirs (projectile-project-p))))

    (defun erlang-mode-prettify-symbols-hook ()
      (setq-local
       prettify-symbols-alist
       (append
        '(("->" . ?→)
          ("=>" . ?⇒)
          ("<-" . ?←)
          ("<=" . ?⇐)
          (">=" . ?≥)
          ("=<" . ?≤)
          ("=/=" . ?≠)
          ("fun" . ?ƒ))
        prettify-symbols-alist)))

    (use-package erlang
      :after (flycheck)
      :init (my/define-erlang-flychecker)
      :mode (("\\.[eh]rl\\'" . erlang-mode)
             ("\\.yaws?\\'" . erlang-mode)
             ("\\.escript?\\'" . erlang-mode))
      :hook ((erlang-mode . erlang-mode-flycheck-hook)
             (erlang-mode . erlang-mode-prettify-symbols-hook)
             (erlang-mode . company-mode)
             (erlang-mode . erlang-mode-compile-hook)))
    #+END_SRC

**** Add zotonic-tpl support
     #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package zotonic-tpl-mode
      :straight (zotonic-tpl-mode :type git :host github :repo "OldhamMade/zotonic-tpl-mode")
      :config
        (add-to-list 'auto-mode-alist '("\\.tpl\\'" . zotonic-tpl-mode)))
     #+END_SRC

*** Python
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package python-mode
      :defer
      :config
        (setq lsp-pyls-plugins-pylint-enabled nil)
        (setq lsp-pyls-plugins-pycodestyle-enabled nil)
      :hook
        (python-mode . subword-mode)
        ;(python-mode .
        ;  (lambda ()
        ;    (defun py-describe-symbol nil)
        ;    (defun py-help-at-point nil)
        ;    ))
      :mode ("\\.py\\'" . python-mode))
    #+END_SRC
**** Add docstring support
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package python-docstring
       :after python
       :bind
       (:map python-mode-map
         ([remap fill-paragraph] . python-docstring-fill)))
     #+END_SRC
**** Better flycheck setup
     Allows multiple syntax checkers to run in parallel on Python code
     Ideal use-case: pyflakes for syntax combined with mypy for typing

     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck-pycheckers
       :after flycheck
       :ensure t
       :init
       (with-eval-after-load 'flycheck
         (add-hook 'flycheck-mode-hook #'flycheck-pycheckers-setup)
         )
       (setq flycheck-pycheckers-checkers
         '(
           mypy3
           pyflakes
           )
         )
       )
     #+END_SRC
**** Manage python projects with poetry
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package poetry
       :ensure t
       :config
         (poetry-tracking-mode 1))
     #+END_SRC
*** Nim
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package nim-mode
      :defer
      :mode ("\\.nim\\'" . nim-mode))
    #+END_SRC
*** Crystal
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package crystal-mode
      :after (ruby-end)
      :defer
      :mode ("\\.cr\\'" . crystal-mode)
      :config
        (add-hook 'crystal-mode-hook 'ruby-block-mode)
        (add-hook 'crystal-mode-hook 'ruby-end-mode))
    #+END_SRC
**** Add flycheck
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flycheck-crystal
      :after (flycheck crystal-mode)
      :defer)
    #+END_SRC
*** Pony
    Disabled for now as I don't use this language often.
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ponylang-mode
      :defer
      :mode ("\\.pony\\'" . ponylang-mode)
      :config (setq tab-width 2))
    #+END_SRC

*** Go-lang
    Disabled for now as I don't use this language often.
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package go-mode
      :defer
      :mode ("\\.go\\'" . go-mode)
      :config
        (setq tab-width 4)
        (add-hook 'go-mode-hook 'flycheck-mode))
    #+END_SRC

**** Add flycheck mode
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck-pony
       :defer)
     #+END_SRC

*** HTML et al
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package web-mode
      :defer
      :config
      ;; use eslint with web-mode for jsx files
      (with-eval-after-load 'flycheck
        (flycheck-add-mode 'javascript-eslint 'web-mode))

      ;; adjust indents for web-mode to 2 spaces
      (defun my-web-mode-hook ()
        "Hooks for Web mode. Adjust indents"
        ;;; http://web-mode.org/
        (setq web-mode-markup-indent-offset 2)
        (setq web-mode-css-indent-offset 2)
        (setq web-mode-code-indent-offset 2))

      (add-hook 'web-mode-hook  'my-web-mode-hook))

    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    ;(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.ecr\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    #+END_SRC
*** JavaScript
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package js2-mode
      :defer
      :config
      (progn
        (setq-default js-indent-level 4)
        (setq-default js2-basic-offset 4)
        (setq tab-width 4)
        (setq js-switch-indent-offset 4)
        ))

    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
    (add-hook 'js2-mode-hook 'company-mode)
    #+END_SRC
*** TypeScript
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package typescript-mode
      :defer
      :mode "\\.ts\\'"
      :config
        (setq typescript-indent-level 2)
        (setq tab-width 2)
        )
    #+END_SRC
*** Sass/Scss
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package sass-mode
      :delight "sass"
      :defer
      :mode ("\\.s(c|a)ss\\'" . sass-mode))
    #+END_SRC
*** Yaml
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yaml-mode
      :defer
      :mode ("\\.ya?ml\\'" . yaml-mode))
    #+END_SRC
*** Markdown
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package markdown-mode
      :delight "md"
      :defer
      :mode ("\\.md\\'" . markdown-mode))
    #+END_SRC
*** Docker
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package dockerfile-mode
      :defer
      :mode ("\\Dockerfile\\'" . dockerfile-mode))
    #+END_SRC
*** RAML
    Disabled for now as I don't use this language often.
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package raml-mode
      :straight (raml-mode :type git :host github :repo "victorquinn/raml-mode")
      :init (setq raml-indent-offset 2)
      :mode "\\.raml\\'")
    #+END_SRC

*** Gherkin/FDD
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package feature-mode
      :mode ("\\.feature$" . feature-mode))
    #+END_SRC
** Terminal
*** Multi-term
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package multi-term
      :delight
      :defer
      :config
      (setq multi-term-program "/bin/zsh"))
    #+END_SRC

*** Misc tweaks
    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq term-scroll-show-maximum-output 1)
    (setq system-uses-terminfo nil)
    (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
    (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
    #+END_SRC
*** Better terminal colours
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package eterm-256color
      :delight
      :init
        (add-hook 'term-mode-hook #'eterm-256color-mode))
    #+END_SRC
** Finalizing
*** Add profiler to diagnose start-up issues
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package esup
      :delight
      :defer)
    #+END_SRC
*** Finally, display how long it took to start up
    #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'emacs-startup-hook
      (lambda ()
        (message "Emacs ready in %s with %d garbage collections."
          (format "%.2f seconds"
            (float-time
              (time-subtract after-init-time before-init-time)))
          gcs-done)))
    #+END_SRC
* TODOs
** Introduce =matcha=
   Matcha may fix a lot of my annoyances about discoverability
   https://github.com/jojojames/matcha
** Display menu for =ace-window=
   I really want to see a =which-key= menu for the
   extra commands available for =ace-window= as I constantly
   forget them.

   Unfortunately =ace-window= doesn't have it's own keymap, and
   I don't want to create a =hydra= for this.
*** Custom keymap
   Current approach would be to create a custom sparse-keymap,
   iterate through =aw-dispatch-alist= and populate the new
   keymap from it, then add some advice to one of the =which-key=
   functions to trigger =which-key-show-minor-mode-keymap=.

   After a time-boxed attempt I have the following, but it isn't
   working yet.
   #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ace-window
      :delight
      :bind ("M-o" . ace-window)
      :config
        (ace-window-display-mode t)
        (setq aw-dispatch-always t)
        (progn
          (setq ace-window-map (make-sparse-keymap))
          (cl-loop for (key . value) in aw-dispatch-alist
                   do (define-key ace-window-map key
                       (if (car-safe value)
                         (quote (car-safe value))
                           (quote value))))))
   #+END_SRC
*** Show available commands using hercules
    Another alternative, but the menu triggers /after/
    =ace-window= has completed, not /during/.
    #+BEGIN_SRC emacs-lisp :tangle no
    (general-def
      :prefix-map 'my-ace-window-map
      "x" #'aw-delete-window
      "m" #'aw-swap-window
      "M" #'aw-move-window
      "c" #'aw-copy-window
      "j" #'aw-switch-buffer-in-window
      "n" #'aw-flip-window
      "u" #'aw-switch-buffer-other-window
      "e" #'aw-execute-command-other-window
      "F" #'aw-split-window-fair
      "v" #'aw-split-window-vert
      "b" #'aw-split-window-horz
      "o" #'delete-other-windows
      "T" #'aw-transpose-frame
      "?" #'aw-show-dispatch-help
      )

    (hercules-def
      :toggle-funs #'ace-window
      :keymap 'my-ace-window-map
      :transient t
      :flatten t)
    #+END_SRC
*** Further reading
**** https://github.com/whitmo/whit-dot-emacs/blob/28f14007a3df9dda092faa6bfeee18d91754a485/lisp/init-ace.el
**** https://github.com/pdcawley/dotemacs/blob/cf6f706fe1f0d59fbf5372ceadb2542b9e0ccf49/config.org#L1546
** =ace-mc= should use home-row keys like =avy=
** Investigate using =ycmd= for code completion
   https://github.com/abingham/emacs-ycmd#company-ycmd
** Add =no-littering=
   https://github.com/emacscollective/no-littering
** Better alchemist menu
*** https://github.com/tonini/alchemist.el/blob/6f99367511ae209f8fe2c990779764bbb4ccb6ed/alchemist.el#L141
** Move from projectile to something lighter
   I don't use 90% of projectile functionality, and can't imagine I
   ever would. Primarily I just want to have a perspective per project,
   and limit searches to that perspective.

   Maybe moving to =project.el= would be better.

   https://old.reddit.com/r/emacs/comments/b0jzy4/emacscast_8_writing_in_emacs_and_org_mode_part_1/eiiywwm/
   https://old.reddit.com/r/emacs/comments/88v344/workspace_with_isolated_buffers_eyebrowseperspmode/
** =dap-mode= for elixir
   https://github.com/emacs-lsp/dap-mode#elixir
** Capture command frequency
   to see whether anything can be removed or should be focused on
   https://github.com/dacap/keyfreq
** =emacs-refactor= for elixir
   https://github.com/Wilfred/emacs-refactor
** Improve refactor using deadgrep
*** Don't edit paths in global search/replace
*** "Read only" text should stay that way
** Remove =M-`= binding
   =M-`= brings up =tmm= which is completely useless to me, so might
   as well be remapped to something handy. Maybe iterate through
   frames/windows?
** Window (pane) management
*** https://github.com/ajgrf/edwina
*** https://github.com/sabof/es-windows
*** https://depp.brause.cc/eyebrowse/
** Buffer navigation
   https://github.com/joostkremers/nswbuff
** FIXME:
*** multiple cursors
**** https://github.com/dhodges/dotfiles/blob/f808e22a2e47133a0fab549db63241a516cf523c/.emacs.d/dh-lisp/dh-packages.el#L276
*** smart-region should load for all modes
